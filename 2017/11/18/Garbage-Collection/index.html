<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Garbage Collection</title>
    <meta name="description" content="  Variable Storage and LifetimeVariable Storage and LifetimeWe need to talk about memory first before talking about GC. So where can variables be stored?  St...">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/assets/stylesheets/main.css ">
    <link rel="canonical" href="https://www.gaeblog.com/2017/11/18/Garbage-Collection/">
    <link rel="alternate" type="application/rss+xml" title="Gae Blog" href="https://www.gaeblog.com/assets/feed.xml ">



    <script>
    // google analytics
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-100686813-1', 'auto');
      ga('send', 'pageview');

    </script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    tex2jax: { inlineMath: [["$","$"],["\\(","\\)"]] },
    "HTML-CSS": {
      linebreaks: { automatic: true, width: "container" }
    }
});
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Garbage Collection | Gae Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Garbage Collection" />
<meta name="author" content="Yanxi Chen" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Variable Storage and Lifetime Variable Storage and Lifetime We need to talk about memory first before talking about GC. So where can variables be stored? Static (compile-time or load time) Stack (runtime) - aka user/runtime/system stack Heap (runtime) For primitive variables, there are 3 categories (given different lifetimes) Globals (static storage) Variables declared outside of any function or class (outermost scope) Scope: accessible to all statements in all functions in the file Lifetime: from start ofprogram (loading) to end (unloading) Good practice: use sparingly, make constant as often as possible Stored in read-only or read-write segments of the process virtual memory space - allocated/fixed before prograrm starts Read-only segment holds translated/native code as well if any Locals (stack storage) Parameters and variables declared within a function Scope: accessible to all statements in the function they are defined Lifetime: from start to end of the function invocation Stored in User/Runtime stack in process virtual memory space Allocated/deallocated with functino invocations and returns Dynamic variables, aka pointer variables (heap storage) Pointer variables that point to variables that are allocated explicitly Scope: global or local depending on where they are declared Lifetime: from program point at which they are allocated with new to the one that at which they are deallocated with delete Pointer variables (the address) are either globals or locals The data they point to is stored in the heap. Here is a graph of a process memory: As we all know, we only do garbage collection on the heap for implicit memory allocation." />
<meta property="og:description" content="Variable Storage and Lifetime Variable Storage and Lifetime We need to talk about memory first before talking about GC. So where can variables be stored? Static (compile-time or load time) Stack (runtime) - aka user/runtime/system stack Heap (runtime) For primitive variables, there are 3 categories (given different lifetimes) Globals (static storage) Variables declared outside of any function or class (outermost scope) Scope: accessible to all statements in all functions in the file Lifetime: from start ofprogram (loading) to end (unloading) Good practice: use sparingly, make constant as often as possible Stored in read-only or read-write segments of the process virtual memory space - allocated/fixed before prograrm starts Read-only segment holds translated/native code as well if any Locals (stack storage) Parameters and variables declared within a function Scope: accessible to all statements in the function they are defined Lifetime: from start to end of the function invocation Stored in User/Runtime stack in process virtual memory space Allocated/deallocated with functino invocations and returns Dynamic variables, aka pointer variables (heap storage) Pointer variables that point to variables that are allocated explicitly Scope: global or local depending on where they are declared Lifetime: from program point at which they are allocated with new to the one that at which they are deallocated with delete Pointer variables (the address) are either globals or locals The data they point to is stored in the heap. Here is a graph of a process memory: As we all know, we only do garbage collection on the heap for implicit memory allocation." />
<link rel="canonical" href="https://www.gaeblog.com/2017/11/18/Garbage-Collection/" />
<meta property="og:url" content="https://www.gaeblog.com/2017/11/18/Garbage-Collection/" />
<meta property="og:site_name" content="Gae Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-11-18T17:30:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Garbage Collection" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Yanxi Chen"},"description":"Variable Storage and Lifetime Variable Storage and Lifetime We need to talk about memory first before talking about GC. So where can variables be stored? Static (compile-time or load time) Stack (runtime) - aka user/runtime/system stack Heap (runtime) For primitive variables, there are 3 categories (given different lifetimes) Globals (static storage) Variables declared outside of any function or class (outermost scope) Scope: accessible to all statements in all functions in the file Lifetime: from start ofprogram (loading) to end (unloading) Good practice: use sparingly, make constant as often as possible Stored in read-only or read-write segments of the process virtual memory space - allocated/fixed before prograrm starts Read-only segment holds translated/native code as well if any Locals (stack storage) Parameters and variables declared within a function Scope: accessible to all statements in the function they are defined Lifetime: from start to end of the function invocation Stored in User/Runtime stack in process virtual memory space Allocated/deallocated with functino invocations and returns Dynamic variables, aka pointer variables (heap storage) Pointer variables that point to variables that are allocated explicitly Scope: global or local depending on where they are declared Lifetime: from program point at which they are allocated with new to the one that at which they are deallocated with delete Pointer variables (the address) are either globals or locals The data they point to is stored in the heap. Here is a graph of a process memory: As we all know, we only do garbage collection on the heap for implicit memory allocation.","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gaeblog.com/2017/11/18/Garbage-Collection/"},"@type":"BlogPosting","headline":"Garbage Collection","dateModified":"2017-11-18T17:30:00+00:00","datePublished":"2017-11-18T17:30:00+00:00","url":"https://www.gaeblog.com/2017/11/18/Garbage-Collection/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">Gae Blog</a>
        <small>Software Engineer@Amazon</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/search/">
                        
                            <i class="fa fa-search"></i>Search
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" post>
    <div class="left">
        <h1>Garbage Collection</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2017-11-18
            </div>

            <div class="label-card">
                <i class="fa fa-user"></i>Yanxi Chen
                
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
            


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Garbage Collection" title="Category: Garbage Collection" rel="category">Garbage Collection</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


            </div>

            <div class="label-card">
            
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <!--a href="/tag/#Garbage+Collection" title="Tag: Garbage Collection" rel="tag">Garbage Collection</a-->
        <a href="/tag/#Garbage Collection" title="Tag: Garbage Collection" rel="tag">Garbage Collection</a>&nbsp;
    
        <!--a href="/tag/#Slides" title="Tag: Slides" rel="tag">Slides</a-->
        <a href="/tag/#Slides" title="Tag: Slides" rel="tag">Slides</a>
    
  

</span>

            </div>

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
        <ul id="markdown-toc">
  <li><a href="#variable-storage-and-lifetime" id="markdown-toc-variable-storage-and-lifetime">Variable Storage and Lifetime</a></li>
  <li><a href="#terminology" id="markdown-toc-terminology">Terminology</a>    <ul>
      <li><a href="#roots-liveness-and-reachability" id="markdown-toc-roots-liveness-and-reachability">Roots, Liveness, and Reachability</a></li>
      <li><a href="#liveness-of-allocated-objects" id="markdown-toc-liveness-of-allocated-objects">Liveness of Allocated Objects</a></li>
    </ul>
  </li>
  <li><a href="#classic-gc-algorithms" id="markdown-toc-classic-gc-algorithms">Classic GC Algorithms</a>    <ul>
      <li><a href="#reference-counting-gc" id="markdown-toc-reference-counting-gc">Reference Counting GC</a>        <ul>
          <li><a href="#strengths" id="markdown-toc-strengths">Strengths</a></li>
          <li><a href="#weaknesses" id="markdown-toc-weaknesses">Weaknesses</a></li>
        </ul>
      </li>
      <li><a href="#mark--sweep-gc" id="markdown-toc-mark--sweep-gc">Mark &amp; Sweep GC</a>        <ul>
          <li><a href="#strengths-1" id="markdown-toc-strengths-1">Strengths</a></li>
          <li><a href="#weaknesses-1" id="markdown-toc-weaknesses-1">Weaknesses</a></li>
        </ul>
      </li>
      <li><a href="#copying-collector" id="markdown-toc-copying-collector">Copying Collector</a>        <ul>
          <li><a href="#strengths-2" id="markdown-toc-strengths-2">Strengths</a></li>
          <li><a href="#weaknesses-2" id="markdown-toc-weaknesses-2">Weaknesses</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#the-principle-of-locality" id="markdown-toc-the-principle-of-locality">The Principle of Locality</a></li>
  <li><a href="#generational-gc" id="markdown-toc-generational-gc">Generational GC</a></li>
  <li><a href="#links" id="markdown-toc-links">Links</a></li>
</ul>

<h1 id="variable-storage-and-lifetime">Variable Storage and Lifetime</h1>

<p>We need to talk about memory first before talking about GC. So where can variables be stored?</p>
<ul>
  <li>Static (compile-time or load time)</li>
  <li>Stack (runtime) - aka user/runtime/system stack</li>
  <li>Heap (runtime)</li>
</ul>

<p>For primitive variables, there are 3 categories (given different lifetimes)</p>
<ul>
  <li>Globals (static storage)
    <ul>
      <li>Variables declared outside of any function or class (outermost scope)</li>
      <li>Scope: accessible to all statements in all functions in the file</li>
      <li>Lifetime: from start ofprogram (loading) to end (unloading)</li>
      <li>Good practice: use sparingly, make constant as often as possible</li>
      <li>Stored in read-only or read-write segments of the process virtual memory space - allocated/fixed before prograrm starts
        <ul>
          <li>Read-only segment holds translated/native code as well if any</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Locals (stack storage)
    <ul>
      <li><strong>Parameters and variables</strong> declared within a function</li>
      <li>Scope: accessible to all statements in the function they are defined</li>
      <li>Lifetime: from start to end of the function invocation</li>
      <li>Stored in User/Runtime stack in process virtual memory space
        <ul>
          <li>Allocated/deallocated with functino invocations and returns</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Dynamic variables, aka pointer variables (heap storage)
    <ul>
      <li>Pointer variables that point to variables that are allocated <em>explicitly</em></li>
      <li>Scope: global or local depending on where they are declared</li>
      <li>Lifetime: from program point at which they are allocated with <code class="language-plaintext highlighter-rouge">new</code> to the one that at which they are deallocated with <code class="language-plaintext highlighter-rouge">delete</code></li>
      <li>Pointer variables (the address) are either globals or locals</li>
      <li>The data they point to is stored in the heap.</li>
    </ul>
  </li>
</ul>

<p>Here is a graph of a process memory:</p>

<p><img src="https://www.gaeblog.com/assets/Garbage-Collection-process.png" alt="" /></p>

<p>As we all know, we only do garbage collection on the heap for implicit memory allocation.</p>

<!--more-->

<h1 id="terminology">Terminology</h1>

<ul>
  <li>Collector
    <ul>
      <li>Part of the runtime that implements memory management</li>
    </ul>
  </li>
  <li>Mutator
    <ul>
      <li>User program - change (mutate) program data structures</li>
    </ul>
  </li>
  <li>Stop-the-world collector - all mutators stop during GC</li>
  <li>Values that a program can manipulate directly
    <ul>
      <li>In processor registers</li>
      <li>On the program stack (includes locals/temporaries)</li>
      <li>In global variables (e.g., array of statics)</li>
    </ul>
  </li>
  <li><strong>Root set</strong> of the computation
    <ul>
      <li>References to heap data held in these locations</li>
      <li>Dynamically allocated data <strong>only</strong> accessible via roots</li>
      <li>A program should not access random locations in heap</li>
    </ul>
  </li>
</ul>

<h2 id="roots-liveness-and-reachability">Roots, Liveness, and Reachability</h2>

<ul>
  <li>Individually allocated pieces of data in the heap are
    <ul>
      <li>Nodes, cells, objects (interchangeably)</li>
      <li>Commonly have header that indicates the type (and thus can be used to identify any references within the object)
        <ul>
          <li>AKA boxed</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Live objects on the heap
    <ul>
      <li><em>Graph of objects that can be “reached” from roots</em>
        <ul>
          <li>Objects that cannot be reached are garbage</li>
        </ul>
      </li>
      <li>An object in the heap is <strong>live</strong> if
        <ul>
          <li>Its address is held in a root, or</li>
          <li>There is a pointer to it held in another live heap object</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="liveness-of-allocated-objects">Liveness of Allocated Objects</h2>

<ul>
  <li>Determined <em>indirectly</em> or <em>directly</em></li>
  <li>Indirectly
    <ul>
      <li>Most common method: <strong>tracing</strong></li>
      <li>Regenerate the set of live nodes whenever a request by the user program for more memory fails</li>
      <li>Start from each root and visit all reachable nodes (via pointers)</li>
      <li>Any node not visited is reclaimed</li>
    </ul>
  </li>
  <li>Directly
    <ul>
      <li>A record is associated with each node in the heap and all references to that node from other heap nodes or roots</li>
      <li>Most common method: <strong>reference counting</strong></li>
      <li>Must be kept up to date as the mutator alters the connectivity of the heap graph</li>
    </ul>
  </li>
</ul>

<h1 id="classic-gc-algorithms">Classic GC Algorithms</h1>

<p>There are mainly three classic GC algorithms</p>

<ul>
  <li>Reference counting</li>
  <li>Mark &amp; Sweep</li>
  <li>Copying</li>
</ul>

<p>For the first two method, we need a thing called <em>Free List</em> which keeps 1+ lists of free chunks that we then fill or break off pieces of to allocated an object</p>

<p><img src="https://www.gaeblog.com/assets/Garbage-Collection-free-list.png" alt="" /></p>

<h2 id="reference-counting-gc">Reference Counting GC</h2>

<ul>
  <li>Each obejct has an additional atomic field in header that holds the humber of pointers to that cell from roots or other objects</li>
  <li>All cells placed in free list initially with count of 0</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">freeList</code> points to the head of the free list</p>
  </li>
  <li>Each time a <em>pointer is set</em> to refer to this cell, the count is incremented</li>
  <li>Each time a reference is removed, count is decremented
    <ul>
      <li>If the count goes to 0
        <ul>
          <li>There is no way for the program to access this cell</li>
        </ul>
      </li>
      <li>The cell is returned to the free list</li>
    </ul>
  </li>
  <li>When a new cell is allocated
    <ul>
      <li>Reference count is set to 1</li>
      <li>Removed from free list
        <ul>
          <li>Assume, for now, that all cells are the same size and each has 3 fields left and right which are references</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://www.gaeblog.com/assets/Garbage-Collection-ref-counting.png" alt="" /></p>

<h3 id="strengths">Strengths</h3>

<ul>
  <li>Memory management overheads are distributed throughout the computation
    <ul>
      <li>Management of active and garbage cells is interleaved with execution</li>
      <li><em>Incremental</em></li>
      <li>Smoother response time</li>
    </ul>
  </li>
  <li>Locality of reference
    <ul>
      <li>Things related are accessed together (for memory hierarchy performance)</li>
      <li>No worse than program itself</li>
    </ul>
  </li>
  <li>Short-lived cells can be reused as soon as they are reclaimed
    <ul>
      <li>We don’t have to wait until memory is exhausted to free cells</li>
      <li>Immediate reuse generates fewer page faults for virtual memory</li>
      <li>Update in place is possible</li>
    </ul>
  </li>
</ul>

<h3 id="weaknesses">Weaknesses</h3>

<ul>
  <li>High processing cost for each pointer update
    <ul>
      <li>When a pointer is overwritten the reference count for <em>both</em> the old and new target cells must be adjusted</li>
      <li>May cause poor memory performance</li>
      <li>Hence, it is not used much in real systems</li>
    </ul>
  </li>
  <li>Extra space in each cell to store count (normally <code class="language-plaintext highlighter-rouge">sizeof(int)</code>)</li>
  <li><strong>Cyclic data structures can’t be reclaimed</strong> (e.g. doubly linked lists)</li>
</ul>

<h2 id="mark--sweep-gc">Mark &amp; Sweep GC</h2>

<ul>
  <li>Tracing collector
    <ul>
      <li>mark-sweep, mark-scan</li>
      <li>use reachability (indirection) to find live objects</li>
    </ul>
  </li>
  <li>Object are <strong>not reclaimed</strong> immediately when they become garbage
    <ul>
      <li>Remain unreachable and undetected until storage is exhausted</li>
    </ul>
  </li>
  <li>When reclamation happens the program is paused
    <ul>
      <li><em>Sweep</em> all currently unused cells back into the freeList</li>
      <li>GC performs a global traversal of all live objects to determine which cells are reachable (<em>live or active</em>)
        <ul>
          <li>Trace, starting from roots, marking them as reachable</li>
          <li>Free all unmarked cells</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Each cell contains 1 bit (markBit) of extra info</li>
  <li>Cells in freeList have markBit set to 0</li>
  <li>No <code class="language-plaintext highlighter-rouge">Update(...)</code> routine necessary</li>
</ul>

<p><img src="https://www.gaeblog.com/assets/Garbage-Collection-mark-sweep.png" alt="" /></p>

<h3 id="strengths-1">Strengths</h3>

<ul>
  <li>Cycles are handled quite normally</li>
  <li>no overhead placed on pointer manipulations</li>
  <li>Better than (incremental) reference counting</li>
</ul>

<h3 id="weaknesses-1">Weaknesses</h3>

<ul>
  <li>Start-stop algorithm (aka stop-the-world)
    <ul>
      <li>Computation is halted while GC happens</li>
      <li>Not practical for real-time systems</li>
    </ul>
  </li>
  <li>Asymptotic complexity is proportional to the size of the heap not just the live objects for sweep</li>
  <li>Fragments memory (scatters free cells across memory)
    <ul>
      <li>Loss of memory performace (caching/paging)</li>
      <li>Allocation is complicated (need to find a set of cells for the right size)</li>
    </ul>
  </li>
  <li><strong>Residency</strong> - heap ocupancy
    <ul>
      <li>As this increases, the need for garbage collection will become more frequent</li>
      <li>Taking processing cycles away from the applicatino</li>
      <li>Allocation and program performance degrades as residency increases</li>
    </ul>
  </li>
</ul>

<h2 id="copying-collector">Copying Collector</h2>

<ul>
  <li>Tracing, stop-the-world collector
    <ul>
      <li>Divide the heap into two <strong>semispaces</strong>
        <ul>
          <li>One with current data</li>
          <li>The other with obsolete data</li>
        </ul>
      </li>
      <li>The roles of the two semispaces is continuously <strong>flipped</strong></li>
      <li>Collector copies live data from the old semispace
        <ul>
          <li><code class="language-plaintext highlighter-rouge">FromSpace</code></li>
          <li>To the new semispace (<code class="language-plaintext highlighter-rouge">ToSpace</code>) when visited</li>
          <li>Pointers to objects in <code class="language-plaintext highlighter-rouge">ToSpace</code> are updated</li>
          <li>Program is restarted</li>
        </ul>
      </li>
      <li><em>Scavengers</em>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">FromSpace</code> is not reclaimed, just abandoned</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://www.gaeblog.com/assets/Garbage-Collection-copying-1.png" alt="" />
<img src="https://www.gaeblog.com/assets/Garbage-Collection-copying-2.png" alt="" /></p>

<h3 id="strengths-2">Strengths</h3>

<ul>
  <li>Have lead to its widespread adoption</li>
  <li>Active data is compact (not fragmented as in mark-sweep)
    <ul>
      <li>More efficient allocation, just grab the next group of cells that fits</li>
      <li>The check for space remaining is simply a pointer comparison</li>
    </ul>
  </li>
  <li>Handles variabl-sized objects naturally</li>
  <li>No overhead on pointer updates</li>
  <li>Allocation is a simple free-space pointer increment</li>
  <li>Fragmentation is eliminated
    <ul>
      <li>Compaction offers improved memory hierarchy performance of the user program</li>
    </ul>
  </li>
</ul>

<h3 id="weaknesses-2">Weaknesses</h3>
<ul>
  <li>Required address space is doubled compared with non-copying collectors
    <ul>
      <li>Primary drawback is the need to divide memory into two</li>
      <li>Performance derades as residency increases (twice as quickly as mark&amp;sweep because half the space)</li>
    </ul>
  </li>
  <li>Touches every page (VM) of the heap regardless of residency of the user program
    <ul>
      <li>Unless both semispaces can be held in memory simultaneously</li>
    </ul>
  </li>
</ul>

<h1 id="the-principle-of-locality">The Principle of Locality</h1>

<ul>
  <li>A good GC should not only reclaim memory but improve the locality of the system on the whole
    <ul>
      <li><em>Principle of locality</em> programs access a relatively small portion of their address space at any particular time (temperal and spacial locality)</li>
      <li>GC should ensure that locality is exploited to improve performance wherever possible</li>
      <li>memory hierarchy was developed to exploit the natural principle of locality in programs
        <ul>
          <li>Different levels of memory each with different speeds/sizes/cost</li>
          <li>Registers, cache, memory, virtual memory</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="generational-gc">Generational GC</h1>

<ul>
  <li>Observations with previous GCs
    <ul>
      <li>Long-lived objects are hard to deal with</li>
      <li>Young objects (recently allocated) die young
        <ul>
          <li><strong>weak-generational hypothesis</strong>: most are young (80-90%)</li>
        </ul>
      </li>
      <li>Large heaps (that can’t be held in memory) degrade performance</li>
    </ul>
  </li>
</ul>

<p>Goal: Make large heaps more efficient by concentrating effort where the reatest payoff is</p>

<ul>
  <li>Segregate objects by age into two or more heap regions
    <ul>
      <li>Generations
        <ul>
          <li>Keep the young generation separate</li>
        </ul>
      </li>
      <li>Collected at different frequencies
        <ul>
          <li>The younger the more often</li>
          <li>The oldest, possible never</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Can be implemented as an incremental scheme or as a stop-the-world scheme
    <ul>
      <li>Using different algorithms on the different regions</li>
    </ul>
  </li>
  <li>Promotion
    <ul>
      <li>Move object to older generation if its survives long enough</li>
    </ul>
  </li>
  <li>Concentrate on youngest generation for reclamation
    <ul>
      <li>This is where most of the recyclable space will be found</li>
      <li>Make this region small so that its collection can be more frequent but with shorter interruption</li>
    </ul>
  </li>
  <li>A younger generation can be collected without collecting an older generation</li>
  <li>The pause time to collect a younger generation is shorter than if a colection of the heap is performed</li>
  <li>Young objs that survive <em>minor</em> collections are <em>promoted</em>
    <ul>
      <li>Minor collections reclaim shortlived objects</li>
    </ul>
  </li>
  <li><strong>Tenured garbage</strong>: garbage in older generations</li>
  <li>Allocation always from minor
    <ul>
      <li>Except perhaps for large or known-to-be-old objects</li>
    </ul>
  </li>
  <li>Minor frequent, major very infrequent</li>
  <li>Major/minor collections can be any type
    <ul>
      <li>Mark/sweep, copying, mark/compact, <strong>hybrid</strong></li>
      <li>Promotion is copying</li>
    </ul>
  </li>
  <li>Can have more than 2 generations
    <ul>
      <li>Each requiring collection of those lower/younger</li>
    </ul>
  </li>
</ul>

<p><img src="https://www.gaeblog.com/assets/Garbage-Collection-nursery-1.png" alt="" />
<img src="https://www.gaeblog.com/assets/Garbage-Collection-nursery-2.png" alt="" />
<img src="https://www.gaeblog.com/assets/Garbage-Collection-nursery-3.png" alt="" />
<img src="https://www.gaeblog.com/assets/Garbage-Collection-nursery-4.png" alt="" />
<img src="https://www.gaeblog.com/assets/Garbage-Collection-nursery-5.png" alt="" /></p>

<ul>
  <li>Minor Collection must be <strong>independent</strong> of major
    <ul>
      <li>need to remember old-to-young references</li>
      <li>Usually not too many - mutations to old objects are infrequent</li>
    </ul>
  </li>
</ul>

<p><img src="https://www.gaeblog.com/assets/Garbage-Collection-generation-1.png" alt="" /></p>

<ul>
  <li><em>What about young-to-old?</em>
    <ul>
      <li>We don’t need to worry about them if we always collect the young each time we collect the old (<strong>major collection</strong>)</li>
    </ul>
  </li>
  <li>Write barriers
    <ul>
      <li>Catching old-to-young pointers</li>
      <li>Code that puts old-generation object into a remembered set
        <ul>
          <li>Traversed as art of root set</li>
          <li>All field assignments aka POINTER UPDATES IN YOUR CODE!</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Alternative to write barriers
    <ul>
      <li>Check all old objeccts to see if they point to a nursery object</li>
      <li>Will negate any benefit we get from generational GC</li>
    </ul>
  </li>
</ul>

<h1 id="links">Links</h1>

<p><a href="https://www.gaeblog.com}/assets/Garbage-Collection-Slides-gc.pdf">Garbage Collection</a></p>

<p><a href="https://www.youtube.com/watch?v=aBehbABx52g&amp;feature=youtu.be">(YouTube: Part 1/3)</a></p>

<p><a href="https://www.youtube.com/watch?v=knMeCv8M9ZE&amp;feature=youtu.be">(YouTube: Part 2/3)</a></p>

<p><a href="https://www.youtube.com/watch?v=qeE7fJTWCew&amp;feature=youtu.be">(YouTube: Part 3/3)</a></p>

        </article>
        <hr>

        
        
            
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
            
            
                
                    
                
                    
                
            
                
                    
                
                    
                
            
        
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2017/10/09/Remote-Shell-Session-Setup/">Remote Shell Session Setup: iTerm2+tmux+mosh</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/2018/02/17/Basic-Programming-Language-Theory/">Basic Programming Language Theory</a></p>
        
    </div>
</div>


        <h2 id="comments">Comments</h2>
        


<div id="disqus_thread"></div>
<script>
    /**
     * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function() {
        this.page.url = 'https://www.gaeblog.com/2017/11/18/Garbage-Collection/'; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://www.gaeblog.com/2017/11/18/Garbage-Collection/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };

    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document,
            s = d.createElement('script');

        s.src = '//https-seraphroy-github-io-1.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>




    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

             <div class="side content" id="search-div">
                 <div>
    <i class="fa fa-search"></i>
    Search
</div>
<div id="site_search">
    <input type="text" id="search_box" placeholder="Search..." >
</div>
<div id="search_results"></div>

<link rel="stylesheet" type="text/css" href="https://www.gaeblog.com/assets/stylesheets/main.css">
<script type="text/javascript" src="https://www.gaeblog.com/assets/js/search.js"></script>
<script type="text/javascript" src="https://www.gaeblog.com/assets/js/node_modules/simpleblogsearch/index.js"></script>

<script>
SimpleBlogSearch({
   searchDataPath: '/assets/search_data.json',
   dataType: 'json',
   processDataFunc: function(data){ return data },
   searchInputID: 'search_box',
   resultsDivID: 'search_results',
   resultULClass: 'content-ul search-ul content-side',
   highlightKeywordClass: 'search_keyword',
   limit: 4,

});
</script>

             </div>
            <!-- Content -->
            <div class="side content">
                <div>
                    Content
                </div>
                <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#variable-storage-and-lifetime">Variable Storage and Lifetime</a></li>
<li class="toc-entry toc-h1"><a href="#terminology">Terminology</a>
<ul>
<li class="toc-entry toc-h2"><a href="#roots-liveness-and-reachability">Roots, Liveness, and Reachability</a></li>
<li class="toc-entry toc-h2"><a href="#liveness-of-allocated-objects">Liveness of Allocated Objects</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#classic-gc-algorithms">Classic GC Algorithms</a>
<ul>
<li class="toc-entry toc-h2"><a href="#reference-counting-gc">Reference Counting GC</a>
<ul>
<li class="toc-entry toc-h3"><a href="#strengths">Strengths</a></li>
<li class="toc-entry toc-h3"><a href="#weaknesses">Weaknesses</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#mark--sweep-gc">Mark &amp; Sweep GC</a>
<ul>
<li class="toc-entry toc-h3"><a href="#strengths-1">Strengths</a></li>
<li class="toc-entry toc-h3"><a href="#weaknesses-1">Weaknesses</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#copying-collector">Copying Collector</a>
<ul>
<li class="toc-entry toc-h3"><a href="#strengths-2">Strengths</a></li>
<li class="toc-entry toc-h3"><a href="#weaknesses-2">Weaknesses</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#the-principle-of-locality">The Principle of Locality</a></li>
<li class="toc-entry toc-h1"><a href="#generational-gc">Generational GC</a></li>
<li class="toc-entry toc-h1"><a href="#links">Links</a></li>
</ul>
                <ul id="content-side" class="content-ul">
                    
                    <li><a href="#comments">Comments</a></li>
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>
<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/assets/js/pageContent.js " charset="utf-8"></script>


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
            
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/SeraphRoy" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="mailto:royxagain@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>     
            <a href="https://www.facebook.com/SeraphRoy" title="Facebook"><i class="fa fa-facebook-official" aria-hidden="true"></i></a>   
            <a href="https://www.linkedin.com/in/yanxichen" title="LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i></a>  
        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /assets/js/main.js " charset="utf-8"></script>
    <script src=" /assets/js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /assets/js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
