<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Condition Variables</title>
    <meta name="description" content="  Introduction – The Bounded Buffer ProblemIntroduction – The Bounded Buffer ProblemIt is possible to use locks (pthread_mutex_lock in pthreads) to implement...">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/assets/stylesheets/main.css ">
    <link rel="canonical" href="https://www.gaeblog.com/2017/06/08/Condition-Variables/">
    <link rel="alternate" type="application/rss+xml" title="Gae Blog" href="https://www.gaeblog.com/assets/feed.xml ">



    <script>
    // google analytics
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-100686813-1', 'auto');
      ga('send', 'pageview');

    </script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    tex2jax: { inlineMath: [["$","$"],["\\(","\\)"]] },
    "HTML-CSS": {
      linebreaks: { automatic: true, width: "container" }
    }
});
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Condition Variables | Gae Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Condition Variables" />
<meta name="author" content="Yanxi Chen" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction – The Bounded Buffer Problem Introduction – The Bounded Buffer Problem It is possible to use locks (pthread_mutex_lock in pthreads) to implement different forms of synchronization, but often it is cumbersome to do so. In particular, there are cases when it is necessary to have one thread wait for something to be computed by another and then only to make progress when that computation has been completed. In the examples we have studied so far, the thread that logically waits is created by the thread that is logically producing the computation upon which that thread is waiting. That is, if thread 1 produces a variable value that will be used by thread 2 (as in the average example in the IntroThreads lecture), thread 1 performs the computation, stores the value, and spawns the threads that then use this computation. This form of parallelism is often called “producer-consumer” parallelism and it occurs in operating systems frequently. In this example, thread 1 “produces” a value that thread 2 consumes (presumably to compute something else). Perhaps more germane to the class at hand, this problem is also called the bounded buffer problem since the buffer used to speed-match the producers and consumers has a fixed length. In an operating systems context, these types of synchronization problems occur frequently. There are cases where threads and/or devices need to communicate, their speeds differ or vary, and the OS must allocate a fixed memory footprint to enable efficient producer-consumer parallelism. While it is logically possible to spawn a new thread that runs every time a new value is produced and to have that thread terminate after it has consumed the value, the overhead of all of the create and join calls would be large. Instead, pthreads includes a way for one thread to wait for a signal from another before proceeding. It is called a condition variable and it is used to implement producer-consumer style parallelism without the constant need to spawn and join threads. Condition variables are a feature of a syncronization primitive called a monitor which is similar to the way in which operating systems kernels work. We won’t discuss them formally at this juncture but their use will become clear as the class progresses. For pthreads, however, condition variables are used to implement test under lock implement wait and signal which as we will see are more or less equivalent usages." />
<meta property="og:description" content="Introduction – The Bounded Buffer Problem Introduction – The Bounded Buffer Problem It is possible to use locks (pthread_mutex_lock in pthreads) to implement different forms of synchronization, but often it is cumbersome to do so. In particular, there are cases when it is necessary to have one thread wait for something to be computed by another and then only to make progress when that computation has been completed. In the examples we have studied so far, the thread that logically waits is created by the thread that is logically producing the computation upon which that thread is waiting. That is, if thread 1 produces a variable value that will be used by thread 2 (as in the average example in the IntroThreads lecture), thread 1 performs the computation, stores the value, and spawns the threads that then use this computation. This form of parallelism is often called “producer-consumer” parallelism and it occurs in operating systems frequently. In this example, thread 1 “produces” a value that thread 2 consumes (presumably to compute something else). Perhaps more germane to the class at hand, this problem is also called the bounded buffer problem since the buffer used to speed-match the producers and consumers has a fixed length. In an operating systems context, these types of synchronization problems occur frequently. There are cases where threads and/or devices need to communicate, their speeds differ or vary, and the OS must allocate a fixed memory footprint to enable efficient producer-consumer parallelism. While it is logically possible to spawn a new thread that runs every time a new value is produced and to have that thread terminate after it has consumed the value, the overhead of all of the create and join calls would be large. Instead, pthreads includes a way for one thread to wait for a signal from another before proceeding. It is called a condition variable and it is used to implement producer-consumer style parallelism without the constant need to spawn and join threads. Condition variables are a feature of a syncronization primitive called a monitor which is similar to the way in which operating systems kernels work. We won’t discuss them formally at this juncture but their use will become clear as the class progresses. For pthreads, however, condition variables are used to implement test under lock implement wait and signal which as we will see are more or less equivalent usages." />
<link rel="canonical" href="https://www.gaeblog.com/2017/06/08/Condition-Variables/" />
<meta property="og:url" content="https://www.gaeblog.com/2017/06/08/Condition-Variables/" />
<meta property="og:site_name" content="Gae Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-08T13:31:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Condition Variables" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Yanxi Chen"},"description":"Introduction – The Bounded Buffer Problem Introduction – The Bounded Buffer Problem It is possible to use locks (pthread_mutex_lock in pthreads) to implement different forms of synchronization, but often it is cumbersome to do so. In particular, there are cases when it is necessary to have one thread wait for something to be computed by another and then only to make progress when that computation has been completed. In the examples we have studied so far, the thread that logically waits is created by the thread that is logically producing the computation upon which that thread is waiting. That is, if thread 1 produces a variable value that will be used by thread 2 (as in the average example in the IntroThreads lecture), thread 1 performs the computation, stores the value, and spawns the threads that then use this computation. This form of parallelism is often called “producer-consumer” parallelism and it occurs in operating systems frequently. In this example, thread 1 “produces” a value that thread 2 consumes (presumably to compute something else). Perhaps more germane to the class at hand, this problem is also called the bounded buffer problem since the buffer used to speed-match the producers and consumers has a fixed length. In an operating systems context, these types of synchronization problems occur frequently. There are cases where threads and/or devices need to communicate, their speeds differ or vary, and the OS must allocate a fixed memory footprint to enable efficient producer-consumer parallelism. While it is logically possible to spawn a new thread that runs every time a new value is produced and to have that thread terminate after it has consumed the value, the overhead of all of the create and join calls would be large. Instead, pthreads includes a way for one thread to wait for a signal from another before proceeding. It is called a condition variable and it is used to implement producer-consumer style parallelism without the constant need to spawn and join threads. Condition variables are a feature of a syncronization primitive called a monitor which is similar to the way in which operating systems kernels work. We won’t discuss them formally at this juncture but their use will become clear as the class progresses. For pthreads, however, condition variables are used to implement test under lock implement wait and signal which as we will see are more or less equivalent usages.","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gaeblog.com/2017/06/08/Condition-Variables/"},"@type":"BlogPosting","headline":"Condition Variables","dateModified":"2017-06-08T13:31:00+00:00","datePublished":"2017-06-08T13:31:00+00:00","url":"https://www.gaeblog.com/2017/06/08/Condition-Variables/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">Gae Blog</a>
        <small>Software Engineer@Amazon</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/search/">
                        
                            <i class="fa fa-search"></i>Search
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" post>
    <div class="left">
        <h1>Condition Variables</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2017-06-08
            </div>

            <div class="label-card">
                <i class="fa fa-user"></i>Yanxi Chen
                
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
            


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Operating System" title="Category: Operating System" rel="category">Operating System</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


            </div>

            <div class="label-card">
            
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <!--a href="/tag/#Thread" title="Tag: Thread" rel="tag">Thread</a-->
        <a href="/tag/#Thread" title="Tag: Thread" rel="tag">Thread</a>
    
  

</span>

            </div>

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
        <ul id="markdown-toc">
  <li><a href="#introduction--the-bounded-buffer-problem" id="markdown-toc-introduction--the-bounded-buffer-problem">Introduction – The Bounded Buffer Problem</a></li>
  <li><a href="#the-clienttrader-example" id="markdown-toc-the-clienttrader-example">The Client/Trader Example</a></li>
  <li><a href="#example-solutions" id="markdown-toc-example-solutions">Example Solutions</a>    <ul>
      <li><a href="#clients" id="markdown-toc-clients">Clients</a></li>
      <li><a href="#traders" id="markdown-toc-traders">Traders</a></li>
      <li><a href="#exectuting-the-examples" id="markdown-toc-exectuting-the-examples">Exectuting the Examples</a></li>
      <li><a href="#understanding-the-examples" id="markdown-toc-understanding-the-examples">Understanding the Examples</a></li>
    </ul>
  </li>
  <li><a href="#solution-1-synchronization-using-mutexes-only" id="markdown-toc-solution-1-synchronization-using-mutexes-only">Solution 1: Synchronization using Mutexes Only</a>    <ul>
      <li><a href="#speed-of-solution-1" id="markdown-toc-speed-of-solution-1">Speed of Solution 1</a></li>
      <li><a href="#the-effects-of-polling" id="markdown-toc-the-effects-of-polling">The Effects of Polling</a></li>
    </ul>
  </li>
  <li><a href="#solution-2-synchronizing-the-order-queue-using-condition-variables" id="markdown-toc-solution-2-synchronizing-the-order-queue-using-condition-variables">Solution 2: Synchronizing the Order Queue using Condition Variables</a>    <ul>
      <li><a href="#test-under-lock" id="markdown-toc-test-under-lock">Test under Lock</a></li>
      <li><a href="#summarizing-pthread_cond_wait-and-pthread_cond_signal" id="markdown-toc-summarizing-pthread_cond_wait-and-pthread_cond_signal">Summarizing pthread_cond_wait() and pthread_cond_signal()</a></li>
      <li><a href="#speed-of-solution-2" id="markdown-toc-speed-of-solution-2">Speed of Solution 2</a></li>
    </ul>
  </li>
  <li><a href="#solution-3-using-a-condition-variable-to-signal-order-fulfillment" id="markdown-toc-solution-3-using-a-condition-variable-to-signal-order-fulfillment">Solution 3: Using a condition variable to signal order fulfillment</a>    <ul>
      <li><a href="#speed-of-solution-3" id="markdown-toc-speed-of-solution-3">Speed of Solution 3</a></li>
    </ul>
  </li>
  <li><a href="#for-your-personal-enjoyment" id="markdown-toc-for-your-personal-enjoyment">For your Personal Enjoyment</a></li>
  <li><a href="#a-brief-word-about-monitors" id="markdown-toc-a-brief-word-about-monitors">A brief word about monitors</a></li>
</ul>

<h2 id="introduction--the-bounded-buffer-problem">Introduction – The Bounded Buffer Problem</h2>

<p>It is possible to use locks (pthread_mutex_lock in pthreads) to implement different forms of synchronization, but often it is cumbersome to do so. In particular, there are cases when it is necessary to have one thread wait for something to be computed by another and then only to make progress when that computation has been completed. In the examples we have studied so far, the thread that logically waits is created by the thread that is logically producing the computation upon which that thread is waiting.</p>

<p>That is, if thread 1 produces a variable value that will be used by thread 2 (as in the average example in the IntroThreads lecture), thread 1 performs the computation, stores the value, and spawns the threads that then use this computation.</p>

<p>This form of parallelism is often called “producer-consumer” parallelism and it occurs in operating systems frequently. In this example, thread 1 “produces” a value that thread 2 consumes (presumably to compute something else).</p>

<p>Perhaps more germane to the class at hand, this problem is also called the <strong>bounded buffer</strong> problem since the buffer used to speed-match the producers and consumers has a fixed length. In an operating systems context, these types of synchronization problems occur frequently. There are cases where threads and/or devices need to communicate, their speeds differ or vary, and the OS must allocate a fixed memory footprint to enable efficient producer-consumer parallelism.</p>

<p>While it is logically possible to spawn a new thread that runs every time a new value is produced and to have that thread terminate after it has consumed the value, the overhead of all of the create and join calls would be large. Instead, pthreads includes a way for one thread to wait for a signal from another before proceeding. It is called a <strong>condition variable</strong> and it is used to implement producer-consumer style parallelism without the constant need to spawn and join threads.</p>

<p>Condition variables are a feature of a syncronization primitive called a <a href="http://en.wikipedia.org/wiki/Monitor_(synchronization)">monitor</a> which is similar to the way in which operating systems kernels work. We won’t discuss them formally at this juncture but their use will become clear as the class progresses. For pthreads, however, condition variables are used to</p>

<ul>
  <li>implement test under lock</li>
  <li>implement wait and signal</li>
</ul>

<p>which as we will see are more or less equivalent usages.</p>

<!--more-->

<h2 id="the-clienttrader-example">The Client/Trader Example</h2>

<p>To make the concepts clearer, consider the following hypothetical example. Imagine that you are to write a simple trading program that allows “clients” to send stock orders to “traders” who are responsible for executing them in a market. Orders should be presented to the traders in first-come, first-served order, but the traders then execute the orders as fast as possible. Further, once a trader has executed an order, it needs to send a signal back to the client that initiated the order indicating that the order has been fulfilled.</p>

<p>Thus clients</p>

<ul>
  <li>create an order</li>
  <li>place it on a queue shared by all traders and clients</li>
  <li>wait for the order to be fulfilled</li>
  <li>
    <p>repeat</p>

    <p>and traders</p>
  </li>
  <li>take an order from the queue</li>
  <li>execute it (buy or sell)</li>
  <li>tell the client who initiated the that the order is fulfilled</li>
  <li>repeat</li>
</ul>

<p>Simple enough?</p>

<p>First, let’s start with a picture. Often the easiest way to begin to understand these types of syncronization problems is with a picture.</p>

<p><img src="https://www.gaeblog.com/assets/Condition-Variables-fig1.png" alt="" /></p>

<p>This will be a simplified example that we’ll implement using pthreads. In it, clients use the queue to send their orders to traders, the traders interact via a single shared “market” and then send responses directly back to clients.</p>

<h2 id="example-solutions">Example Solutions</h2>

<p>We’ll go through several solutions that are based on the same code base. They differ only in the way that they syncronize the clients and traders. To understand the effects of these difference it is best to first understand the code that is common to all of them.</p>

<p>There four main data structures:</p>

<ul>
  <li><strong>order</strong>: specifying a stock, a quantity, an action (BUY/SELL), and a flag indicating when the order has been fulfilled</li>
  <li><strong>order_que</strong>: a one-dimensional array of pointers to orders that is managed as a FIFO using a head and tail index</li>
  <li><strong>stock</strong>: a counter indicating the quantity of a stock that is currently available for sale</li>
  <li><strong>market</strong>: a one-dimensional array of stocks indexed by stock ID</li>
</ul>

<p>Here are the C structure definitions for these data structures:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">order</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">stock_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">quantity</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">action</span><span class="p">;</span> <span class="cm">/* buy or sell */</span>
    <span class="kt">int</span> <span class="n">fulfilled</span><span class="p">;</span>  
<span class="p">};</span>

<span class="k">struct</span> <span class="n">order_que</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">order</span> <span class="o">**</span><span class="n">orders</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>
    <span class="n">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">market</span>
<span class="p">{</span>
    <span class="n">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">stocks</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Notice that the <em>struct market</em> structure just uses an array of integers to represent the array of possible stocks. Each stock is named by an integer that is passed from client to trader in the <em>int stock_id</em> field of the order.</p>

<p>The <em>struct order_que</em> has a pointer to an array of pointers to orders, a head and tail pointer to use for the FIFO, and a size indicating how many elements there are in the array of pointers to orders. Thus each element in the queue points to an order that has been dynamically allocated. The size of that queue of pointers is also used to dynamically allocate the array itself. To see how this works, it is helpful to study the constructor function for a <em>struct order_que</em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">order_que</span> <span class="o">*</span><span class="nf">InitOrderQue</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">order_que</span> <span class="o">*</span><span class="n">oq</span><span class="p">;</span>

        <span class="n">oq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">order_que</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">order_que</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">oq</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">oq</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">order_que</span><span class="p">));</span>

        <span class="n">oq</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* empty condition burns a slot */</span>
        <span class="n">oq</span><span class="o">-&gt;</span><span class="n">orders</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">order</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">oq</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">order</span> <span class="o">*</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">oq</span><span class="o">-&gt;</span><span class="n">orders</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">free</span><span class="p">(</span><span class="n">oq</span><span class="p">);</span>
                <span class="k">return</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">oq</span><span class="o">-&gt;</span><span class="n">orders</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">order</span> <span class="o">*</span><span class="p">));</span>

        <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>

        <span class="k">return</span><span class="p">(</span><span class="n">oq</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice that the <em>size</em> parameter is used to <em>malloc()</em> an array of pointers to <em>struct order</em> data types. If you don’t understand this use of <em>malloc()</em> and pointers, stop here and review. It will be important since dynamic memory allocation, arrays, structures, and pointers are <strong>essential</strong> to success in this class.</p>

<h3 id="clients">Clients</h3>

<p>Each solution is a simulation of the client-trader interaction. In it, clients, create orders for stocks that consist of</p>

<ul>
  <li>a randomly selected stock among all possible stocks</li>
  <li>a random quantity for the transaction for that stock</li>
  <li>a BUY or SELL action, again selected randomly</li>
</ul>

<p>Notice that price doesn’t factor into the simulation. It is possible to introduce a notion of price but it requires a third type of actor (the market maker) to adjust prices based on supply and demand. To keep it simple, we’ll assume that each client “knows” that she wants to trade at what ever the current price is (which isn’t represented in the simulation).</p>

<p>Clients create a <em>struct order</em> data type, fill it it with their randomly generated order information, and queue it on an order queue (of which there will only be one in these examples). Then the client waits for the <em>int fulfilled</em> flag to indicate that the order has been fulfilled by a trader (which will set the flag to <em>1</em>).</p>

<h3 id="traders">Traders</h3>

<p>Traders each dequeue and order from the order queue and execute the trade with a market (of which there will only be one in these examples). To do so, they use the <em>int stock_id</em> in the <em>struct order</em> as an index into the <em>struct market</em> and then either decrement the value in the <em>int *stocks</em> array if the action is a BUY, or they increment it if the action is a SELL. For simplicity, the value in an element of the <em>int *stocks</em> array is never allowed to go negative. Then, after an order has been fulfilled, the trader sets the <em>int fulfilled</em> flag in the order to <em>1</em>.</p>

<p>The client has to retain a pointer to the order so that it ca “see” when the order has been fulfilled, deallocate the order, and loop around to create a new one.</p>

<h3 id="exectuting-the-examples">Exectuting the Examples</h3>

<p>Each example uses the same argument list</p>

<ul>
  <li>-c client_count: specifies the number of client threads</li>
  <li>-t trader_count: specifies the number of trader thread</li>
  <li>-o order_count: specifies the total number of orders each client will issue before finishing</li>
  <li>-s stock_count: specifies the number of stocks in the market</li>
  <li>-q queue_size: specifies the size of the queue to use between clients and traders</li>
  <li>-V: sets the verbose flag on so that the simulation prints out internal information (slows the execution down)</li>
</ul>

<p>Thus, for example, the first solution discussed as</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./market1 <span class="nt">-c</span> 10 <span class="nt">-t</span> 10 <span class="nt">-s</span> 100 <span class="nt">-q</span> 5 <span class="nt">-o</span> 1000
</code></pre></div></div>

<p>says to runs the simulation with 10 clients, 10 traders, 100 stocks, a queue size of 5, and each client will issues and wait for 1000 orders to complete.</p>

<p>Without the <em>-V</em> each simulation prints out the transaction rate. That is, the number of orders/second the entire simulation was able to achieve using the parameters specified.</p>

<h3 id="understanding-the-examples">Understanding the Examples</h3>

<p>In these lecture notes, we’ll focus on specific aspects of the code that have to do with the way in which the clients and traders (each represented by a thread) must synchronize. We won’t cover possible useful details like the way in which the arguments are parsed. That information, however, is available to you in the source code itself and you are encouraged to study it. It is also helpful if you make copies of these examples, build them, and run them as you may find yourself wanting to use parts of these programs for your own assignments.</p>

<p>All of the examples and a makefile are available from <a href="http://www.cs.ucsb.edu/~rich/class/cs170/notes/CondVar/example">http://www.cs.ucsb.edu/~rich/class/cs170/notes/CondVar/example</a></p>

<h2 id="solution-1-synchronization-using-mutexes-only">Solution 1: Synchronization using Mutexes Only</h2>

<p>In the first attempted solution we’ll look at how the syncronization works if you used only the pthread mutex data type. The <a href="https://www.gaeblog.com/assets/market1.c">market1</a>.</p>

<p>First look at the arguments passed to the client thread:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">client_arg</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">order_count</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">order_que</span> <span class="o">*</span><span class="n">order_que</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">max_stock_id</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">max_quantity</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">verbose</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The clients need to know the address of the order queue (<em>struct order_que *)</em>), how many orders to place (<em>int order count</em>), the maximum ID to use when choosing a stock (<em>int max_stock_id</em>), the maximum quantity to use when choosing a quantity (<em>max_quantity</em>) an id for printing and the verbose flag.</p>

<p>Note that the pointer the order queue will be the same for all clients so that they share the same queue.</p>

<p>Next look at the body of the client thread code</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">ClientThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">client_arg</span> <span class="o">*</span><span class="n">ca</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">client_arg</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">order</span> <span class="o">*</span><span class="n">order</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">stock_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">quantity</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">action</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">queued</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">now</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*
         * create an order for a random stock
         */</span>
        <span class="n">stock_id</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">RAND</span><span class="p">()</span> <span class="o">*</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">max_stock_id</span><span class="p">);</span>
        <span class="n">quantity</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">RAND</span><span class="p">()</span> <span class="o">*</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">max_quantity</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">RAND</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* 0 =&gt; buy */</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">action</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* 1 =&gt; sell */</span>
        <span class="p">}</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">InitOrder</span><span class="p">(</span><span class="n">stock_id</span><span class="p">,</span><span class="n">quantity</span><span class="p">,</span><span class="n">action</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"no space for order</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
         <span class="cm">/*
           queue it for the traders
         */</span>
        <span class="n">queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">queued</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
            <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
            <span class="cm">/*
             * is the queue full?
             */</span>
            <span class="k">if</span><span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span><span class="o">**</span> 
            <span class="cm">/*
             * there is space in the queue, add the order and bump
             * the head
             */</span>
            <span class="k">if</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">CTimer</span><span class="p">();</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%10.0f client %d: "</span><span class="p">,</span><span class="n">now</span><span class="p">,</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"queued stock %d, for %d, %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">order</span><span class="o">-&gt;</span><span class="n">stock_id</span><span class="p">,</span>
                    <span class="n">order</span><span class="o">-&gt;</span><span class="n">quantity</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">?</span> <span class="s">"SELL"</span> <span class="o">:</span> <span class="s">"BUY"</span><span class="p">));</span> 
            <span class="p">}</span>
             <span class="o">**</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">orders</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
            <span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>

            <span class="cm">/*
             * spin waiting until the order is fulfilled
             */</span>
            <span class="k">while</span><span class="p">(</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">fulfilled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span><span class="o">**</span> 
            <span class="cm">/*
             * done, free the order and repeat
             */</span>
            <span class="n">FreeOrder</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this code segment the lines where the client is synchronizing are in bold face. Notice that the head and tail pointers for the share order queue must be managed as a critical section. Each client must add an order and update the head and tail pointers atomically.</p>

<p>To do this using <em>pthread_mutex_t</em> is a little tricky. Why? Because when the client must test to make sure the queue isn’t full before it updates the head and tail pointers (or an order will be lost). If the queue is full, the client must wait, but it can’t stop and wait holding the lock or a deadlock will occur. Thus, when the queue is full, the client must drop its lock (so that a trader can get into the critical section to dequeue an order thereby opening a slot) and loop back around to try again.</p>

<p>This type of syncronization is called “polling” since the client “polls” the full condition and loops while the condition polls as true.</p>

<p>Notice also that the client comes out of the polling loop holding the lock so that it adds the order to the queue and moves the head pointer atomically. Only after it has successfully added the order to the queue does the client drop its lock.</p>

<p>The other tricky business here is in the code where the client waits for the trader to fulfill the order</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// spin waiting until the order is fulfilled</span>
<span class="k">while</span><span class="p">(</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">fulfilled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>Why is there no lock? Notice that the lock for the order has been dropped. Should there be a lock here?</p>

<p>Well, if there is, it can’t be the same lock as the one for the order queue or the trader (which will also use this lock to test the empty condition) won’t be able to get into the critical section to dequeue an order. It is possible to have added a <em>pthread_mutex_t lock</em> to the order structure but the syncronization of the fulfillment of a single order is between a single client and a single trader. That is, the client and trader are not racing. Rather, the trader needs to send a signal to the client that the trade is done and the client needs to wait for that signal. Since there is only going to be one client waiting and one trader sending the signal, the client can simply “spin” polling the value of the <em>int fulfilled</em> flag until the trader sets it to <em>1</em>. This method of syncronization works <em>only</em> if the memory system of the processor guarantees that memory reads and writes are atomic (which the x86 architecture does).</p>

<p>Thus the while loop shown above simply spins until the value in the order structure gets set to 1, thereby “holding” the client until the trade completes.</p>

<p>The trader thread code is as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">TraderThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">trader_arg</span> <span class="o">*</span><span class="n">ta</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trader_arg</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dequeued</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">order</span> <span class="o">*</span><span class="n">order</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">now</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">next</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
         <span class="o">**</span><span class="n">dequeued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">dequeued</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
            <span class="cm">/*
             * is the queue empty?
             */</span>
            <span class="k">if</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
                <span class="cm">/*
                 * if the queue is empty, are we done?
                 */</span>
                <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span><span class="o">**</span> 
            <span class="cm">/*
             * get the next order
             */</span>
            <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">orders</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
            <span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
             <span class="o">**</span><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span><span class="o">**</span> 
            <span class="n">dequeued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/*
         * have an order to process
         */</span>
         <span class="o">**</span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">market</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* BUY */</span>
            <span class="n">ta</span><span class="o">-&gt;</span><span class="n">market</span><span class="o">-&gt;</span><span class="n">stocks</span><span class="p">[</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">stock_id</span><span class="p">]</span> <span class="o">-=</span> <span class="n">order</span><span class="o">-&gt;</span><span class="n">quantity</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">market</span><span class="o">-&gt;</span><span class="n">stocks</span><span class="p">[</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">stock_id</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ta</span><span class="o">-&gt;</span><span class="n">market</span><span class="o">-&gt;</span><span class="n">stocks</span><span class="p">[</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">stock_id</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">ta</span><span class="o">-&gt;</span><span class="n">market</span><span class="o">-&gt;</span><span class="n">stocks</span><span class="p">[</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">stock_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">order</span><span class="o">-&gt;</span><span class="n">quantity</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">market</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span><span class="o">**</span> 
        <span class="k">if</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">CTimer</span><span class="p">();</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%10.0f trader: %d "</span><span class="p">,</span><span class="n">now</span><span class="p">,</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"fulfilled stock %d for %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">order</span><span class="o">-&gt;</span><span class="n">stock_id</span><span class="p">,</span>
                <span class="n">order</span><span class="o">-&gt;</span><span class="n">quantity</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/*
         * tell the client the order is done
         */</span>
         <span class="o">**</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">fulfilled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="o">**</span> 
    <span class="p">}</span>

    <span class="k">return</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the trader thread there are three synchronization events (which I have tried to boldface).</p>

<ul>
  <li>synchronizing on the empty condition and head/tail pointers of the order queue</li>
  <li>synchronizing with other traders on the stock record in the market</li>
  <li>setting the fulfilled flag in the order structure to tell the client the order is completed</li>
</ul>

<p>Like with the client, the trader takes a lock, then tests the condition of the queue only this time it is looking to make sure the queue is not empty (while the client is worried about the queue being full). If the queue is empty, the trader must drop the lock and loop around until there is work. It then comes out of the loop holding the lock so it can dequeue the order and move the head and tail pointer atomically.</p>

<p>The trader includes an additional wrinkle for shutting down the entire simulation. In the case of the client, the main loop runs for as many orders as there are going to be for each client. The traders, however, don’t know when the clients are done. To tell the traders, the trader argument structure</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">trader_arg</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">order_que</span> <span class="o">*</span><span class="n">order_que</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">market</span> <span class="o">*</span><span class="n">market</span><span class="p">;</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">done</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">verbose</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>includes a pointer to an integer (<em>int *done</em>) which will be set to <em>1</em> by the main thread once it has joined with all of the clients. That is, the main thread will try and join will all clients (which will each finish once their set of orders is processed), set the done flag, and then join with all traders. Take a look at the <em>main()</em> function in <a href="https://www.gaeblog.com/assets/market1.c">the source code</a> to see the details. However, in the spin loop where the trader is waiting for the queue not to be empty, it must also test to see if the main thread has signaled that the simulation is done.</p>

<p>Note also that the traders must synchronize when accessing the market since each BUY or SELL order must be processed atomically. That is, there is a race condition with respect to updating the stock balance that the traders must avoid by accessing the market atomically.</p>

<p>Finally, once an order has been successfully executed, the trader sets the <em>int fulfilled</em> flag to tell the client that it can continue.</p>

<h3 id="speed-of-solution-1">Speed of Solution 1</h3>

<p>On the machine I used (my laptop which is a Mac with a 2.8Hz i7 having 2 cores and hyperthreading), I get the following outputs:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MossPiglet% ./market1 <span class="nt">-c</span> 1 <span class="nt">-t</span> 1 <span class="nt">-q</span> 1 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
160194.266347 transactions / sec

MossPiglet% ./market1 <span class="nt">-c</span> 1 <span class="nt">-t</span> 1 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
178848.307204 transactions / sec

MossPiglet% ./market1 <span class="nt">-c</span> 1 <span class="nt">-t</span> 2 <span class="nt">-q</span> 1 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
69281.818970 transactions / sec

MossPiglet% ./market1 <span class="nt">-c</span> 1 <span class="nt">-t</span> 2 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
67015.364164 transactions / sec

MossPiglet% ./market1 <span class="nt">-c</span> 2 <span class="nt">-t</span> 2 <span class="nt">-q</span> 1 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
116164.790273 transactions / sec

MossPiglet% ./market1 <span class="nt">-c</span> 2 <span class="nt">-t</span> 2 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
116390.389026 transactions / sec

MossPiglet% ./market1 <span class="nt">-c</span> 100 <span class="nt">-t</span> 100 <span class="nt">-q</span> 100 <span class="nt">-s</span> 1 <span class="nt">-o</span> 10
425.016132 transactions / sec
</code></pre></div></div>

<p>Stare at these results for a minute. Hilarious, no? What do they say, and then (more importantly) what do they mean?</p>

<p>First, on my Mac, the best performance is when there is 1 client, 1 trader, and a good sized queue between them to speed match. With 2 physical cores and only two threads you’d expect pretty good performance (especially if the i7 and OSX keeps the threads pinned to cores).</p>

<p>You can also see that hyperthreading isn’t doing you much good. Intel says it gives you almost two additional “virtual cores” but when we run this code with 2 clients and 2 traders, the performance goes down by about a third. So much for virtual cores (at least under OSX – try this on Linux and see if it is any better).</p>

<p>The size of the queue seems to matter sometimes, but not others (that’s curious). And the performance is <strong>abysmal</strong> when there are 100 clients and 100 traders.</p>

<h3 id="the-effects-of-polling">The Effects of Polling</h3>

<p>Clearly there are interesting and (perhaps) bizarre interactions taking place between the implementation of pthreads that is available for OSX and the Intel i7. However one thing is certain from the code: <strong>polling wastes CPU time slices</strong>. That is, when a thread is looping it is entitled to do so for its entire time slice. For the duration of that time slice (technically speaking – will discuss the exception in a minute) the thread is guaranteed <em>not</em> to be descheduled for another thread. Time slices are in the 50ms to 100ms range these days.</p>

<p>However, to see this effect, think of an extreme example where the time slice is 1 second. That is, when a thread is given the CPU, it will use it for 1 second <strong>unless</strong> it tries to do an I/O (print to the screen, etc.). Imagine that there is one processor (no hyperthreading), 1 client thread, and 1 trader thread. What is the maximum transaction rate? It should be about 0.5 transactions / second since in every second, there is a 50% chance that a client thread or trader thread is assigned the processor and during that second it simply spins waiting. Thus in half of the second, no work gets done while the CPU allows the spinning thread to run out its time slice.</p>

<p>It turns out that OSX (and Linux) is likely smarter than I’ve indicated in this simple thought experiment. Both of these systems “know” that the client and trader threads are calling <em>pthread_mutex_lock()</em> in their spin loops. The lock call generates a system call and there are <a href="https://software.intel.com/en-us/node/506266">really tricky locking features</a> that can be employed. However in the client while loop where it waits for the <em>int fulfilled</em> flag and there is no lock, the OS has no choice but to let the thread spin out its time slice.</p>

<h2 id="solution-2-synchronizing-the-order-queue-using-condition-variables">Solution 2: Synchronizing the Order Queue using Condition Variables</h2>

<p>Here is <a href="https://www.gaeblog.com/assets/market2.c">the source code for a solution that uses condition variables to synchronize the order queue</a>. Notice a change to the order queue structure:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">order_que</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">order</span> <span class="o">**</span><span class="n">orders</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">head</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">tail</span><span class="p">;</span>
        <span class="n">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
        <span class="n">pthread_cond_t</span> <span class="n">full</span><span class="p">;</span>
        <span class="n">pthread_cond_t</span> <span class="n">empty</span><span class="p">;</span><span class="o">**</span> 
<span class="p">};</span>
</code></pre></div></div>

<p>in which two condition variables (for the full and empty conditions) have been added. In the client thread, the queue synchronization becomes</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="n">queued</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="o">**</span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span><span class="o">**</span> 
    <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="cm">/*
     * is the queue full?
     */</span>
    <span class="k">while</span><span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
         <span class="o">**</span><span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">),</span>
                  <span class="o">&amp;</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span><span class="o">**</span> 
        <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Notice how this works. Like before, the client must take a mutex lock. However, the <em>pthread_cond_wait()</em> primitive allows the client to “sleep” until it has been signaled and to <strong>automatically drop the lock</strong> just before going to sleep. The client will sleep (not spinning on the CPU) until some other thread calls <em>pthread_cond_signal()</em> on the same condition variable that was specified as the first argument to <em>pthread_cond_wait()</em>. To be able to drop the lock on behalf of the client, the call to <em>pthread_cond_wait()</em> must also take (as its second argument) the address of the lock to drop.</p>

<p>The <em>pthread_cond_wait()</em> primitive also has another important property. When the client is awoken by some call to <em>pthread_cond_signal()</em> it will be allowed to try and acquire the lock <em>before</em> the call to <em>pthread_cond_wait()</em> completes. Thus, when the wait is over, the client “wakes up” holding the lock.</p>

<h3 id="test-under-lock">Test under Lock</h3>

<p>This features is called test-under-lock because it allows the caller of “wait” to hold a lock, conduct a condition test, and sleep all as a single atomic operation. It also, then, gives the caller the lock back once the wait completes. Note that you can’t easily implement test-under-lock with mutexes and sleep. For example, if you were to write</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="cm">/*
     * whoops -- what if it goes to not full here?
     */</span>
    <span class="n">sleep</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>There is a moment in time right between the call to <em>pthread_mutex_unlock()</em> and <em>sleep()</em> where the queue status could change from full to not full. However, the thread will have already decided to go to sleep and, thus, will never wake up.</p>

<p>The <em>pthread_cond_wait()</em> call is specially coded to avoid this race condition.</p>

<p>Now take a look at the trader thread just after the thread has determined that there is work to do:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//get the next order</span>
    <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">orders</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
    <span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
     <span class="o">**</span><span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">));</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span><span class="o">**</span> 
    <span class="n">dequeued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>The trader thread must call <em>pthread_cond_signal()</em> on the same condition variable that the client threads are using to wait for the queue to no longer be full.</p>

<p>Similarly, the trader thread (before it processes an order) must ensure that there is work in the queue. That is, it cannot proceed until the queue is no longer empty. Its code is</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dequeued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">dequeued</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
    <span class="cm">/*
     * is the queue empty?
     */</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*
         * if the queue is empty, are we done?
         */</span>
        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">));</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
            <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
         <span class="o">**</span><span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">),</span>
                  <span class="o">&amp;</span><span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span><span class="o">**</span> 
    <span class="p">}</span>
</code></pre></div></div>

<p>Here the trader thread is waiting while the queue is empty. Thus, the client thread must signal a waiting trader (if there is one) once it has successfully queued an order. In the client thread</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">orders</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
    <span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
     <span class="o">**</span><span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">));</span><span class="o">**</span> 
    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">ca</span><span class="o">-&gt;</span><span class="n">order_que</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">));</span>
</code></pre></div></div>

<h3 id="summarizing-pthread_cond_wait-and-pthread_cond_signal">Summarizing pthread_cond_wait() and pthread_cond_signal()</h3>

<p>In this example, there are two condition variables in <em>struct order_que</em>:</p>

<ul>
  <li>empty: which is signaled by a client when the queue is not empty</li>
  <li>full: which is signaled by a trader when the queue is no longer full</li>
</ul>

<p>Clients must call <em>pthread_cond_wait()</em> on the <em>full</em> variable when the detect that the queue is full. Traders must call <em>pthread_cond_wait()</em> on the <em>empty</em> variable when they detect that the queue is empty.</p>

<p>The API for condition variables is</p>

<ul>
  <li><strong>int pthread_cond_init(pthread_cond_t *variable, pthread_cond_attr_t *attr)</strong>: initializes a condition variable (second argument NULL says to use pthreads defaults)</li>
  <li><strong>int pthread_cond_wait(pthread_cond_t *variable, pthread_mutex_t *lock)</strong>: sleep until a signal is sent to the condition variable passed in the first argument and will reacquire the lock (passed as the second variable) before the wait completes.</li>
  <li><strong>int pthread_cond_signal(pthread_cond_t *variable)</strong>: signals at least one thread blocked on the condition variable passed as its first argument.</li>
</ul>

<p>There are several interesting caveats to understand about the pthread specification with respect to condition variables. First, a signal sent to a variable where no thread is waiting is just a noop (i.e. it does nothing). Notice that in Solution 2, the clients and traders <em>always</em> call <em>pthread_cond_signal()</em> regardless of whether there is a thread waiting or not. Signals that come in when no threads are waiting are just lost.</p>

<p>Thus, in this example, the calls to <em>pthread_cond_signal()</em> occur under the same lock that is being used to control the wait. That way, the signaler “knows” it is in the critical section and hence no other thread is in its critical section so there is no race condition that could cause a lost signal.</p>

<p>Another, more subtle point, is that a thread that has been signaled is not <em>guaranteed</em> to acquire the lock <em>immediately</em>. Notice that in the example, each thread retests the condition in a loop when it calls <em>pthread_cond_wait()</em>. That’s because between the time it is signaled and the time it reacquires the lock, another thread might have “snuck in” grabbed the lock, changed the condition, and released the lock.</p>

<p>Most implementations try and give priority to a thread that has just awoken from a call to <em>pthread_cond_wait()</em> but that is for performance and not correctness reasons. To be completely safe, the threads must retest after a wait since the immediate lock acquisition is not strictly guaranteed by the specification.</p>

<p>Lastly, the specification does not say which thread (among more than one that are waiting on a condition variable) should be awakened. Again, good implementations try and choose threads to wake up in FIFO order as a default, but that isn’t guaranteed (and may not be desirable in all situations). You should never count on the implementation of wait/signal in pthreads being “fair” to the threads that are waiting.</p>

<h3 id="speed-of-solution-2">Speed of Solution 2</h3>

<p>Here are the performance results for the same set of tests as for Solution 1:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MossPiglet% ./market2 <span class="nt">-c</span> 1 <span class="nt">-t</span> 1 <span class="nt">-q</span> 1 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
291456.104778 transactions / sec

MossPiglet% ./market2 <span class="nt">-c</span> 1 <span class="nt">-t</span> 1 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
283434.731280 transactions / sec

MossPiglet% ./market2 <span class="nt">-c</span> 1 <span class="nt">-t</span> 2 <span class="nt">-q</span> 1 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
294681.020728 transactions / sec

MossPiglet% ./market2 <span class="nt">-c</span> 1 <span class="nt">-t</span> 2 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
293809.091170 transactions / sec

MossPiglet% ./market2 <span class="nt">-c</span> 2 <span class="nt">-t</span> 2 <span class="nt">-q</span> 1 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
105729.484982 transactions / sec

MossPiglet% ./market2 <span class="nt">-c</span> 2 <span class="nt">-t</span> 2 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
102448.573029 transactions / sec

MossPiglet% ./market2 <span class="nt">-c</span> 100 <span class="nt">-t</span> 100 <span class="nt">-q</span> 100 <span class="nt">-s</span> 1 <span class="nt">-o</span> 10
369.965854 transactions / sec
</code></pre></div></div>

<p>Yee haw! Not bad, eh? The best Solution 1 could do was about 178K transactions per second and Solution 2 goes like 295K transactions per second. Hyperthreading does even worse relative to non-hyperthreading in Solution 2, but it is still 40% faster than its Solution 1 counterpart. However, the test with a bunch of threads still really performs badly. Let’s fix that.</p>

<h2 id="solution-3-using-a-condition-variable-to-signal-order-fulfillment">Solution 3: Using a condition variable to signal order fulfillment</h2>

<p>The problem here with the last test is that all of the clever scheduling tricks that the pthreads implementation is using are failing for the spin loop in the client where it waits for the order to be fulfilled. The pthreads code doesn’t “know” a spin is taking place so it can’t tell the OS to deprioritize the clients while they wait. When there are a lot of clients there is a lot of useless spinning. However we now know how to fix this problem: use a condition variable to implement a wait and signal. <a href="https://www.gaeblog.com/assets/market3.c">Here is the complete source code for Solution 3</a>.</p>

<p>First, we add a condition variable to <em>struct order</em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">order</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">stock_id</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">quantity</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">action</span><span class="p">;</span>     <span class="cm">/* buy or sell */</span>
        <span class="kt">int</span> <span class="n">fulfilled</span><span class="p">;</span>
 <span class="o">**</span><span class="n">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
        <span class="n">pthread_cond_t</span> <span class="n">finish</span><span class="p">;</span><span class="o">**</span> 
<span class="p">};</span>
</code></pre></div></div>

<p>Notice that we had to add a lock as well. Condition variables implement “test under lock” which means we need to “test” the fulfilled condition under a lock or there will be a race condition.</p>

<p>Next, in the client thread, we lock the order, test its condition (in case the trader thread has already fulfilled the order) and wait if it hasn’t:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//wait using condition variable until</span>
    <span class="c1">//order is fulfilled</span>
     
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">fulfilled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">finish</span><span class="p">,</span><span class="o">&amp;</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>

<p>Then, in the trader thread, instead of just setting the fulfilled flag</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//tell the client the order is done</span>

    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">order</span><span class="o">-&gt;</span><span class="n">fulfilled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">finish</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>

<p>Notice that the flag must be set inside a critical section observed by both the client and the trader threads. Otherwise, bad timing might allow the trader thread to sneak in, set the value, and send a signal that is lost in between the time the client tests the flag and calls <em>pthread_cond_wait()</em>. Think about this possibility for a minute. What happens if we remove the call to <em>pthread_mutext_lock()</em> and <em>pthread_mutex_unlock()</em> in the trader thread. Can you guarantee that the code won’t deadlock?</p>

<h3 id="speed-of-solution-3">Speed of Solution 3</h3>

<p>Here are the same runs as before:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MossPiglet% ./market3 <span class="nt">-c</span> 1 <span class="nt">-t</span> 1 <span class="nt">-q</span> 1 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
156951.367687 transactions / sec

MossPiglet% ./market3 <span class="nt">-c</span> 1 <span class="nt">-t</span> 1 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
151438.489162 transactions / sec

MossPiglet% ./market3 <span class="nt">-c</span> 1 <span class="nt">-t</span> 2 <span class="nt">-q</span> 1 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
150724.983497 transactions / sec

MossPiglet% ./market3 <span class="nt">-c</span> 1 <span class="nt">-t</span> 2 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
146666.960399 transactions / sec

MossPiglet% ./market3 <span class="nt">-c</span> 2 <span class="nt">-t</span> 2 <span class="nt">-q</span> 1 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
91147.153955 transactions / sec

MossPiglet% ./market3 <span class="nt">-c</span> 2 <span class="nt">-t</span> 2 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 100000
90862.384876 transactions / sec

MossPiglet% ./market3 <span class="nt">-c</span> 100 <span class="nt">-t</span> 100 <span class="nt">-q</span> 100 <span class="nt">-s</span> 1 <span class="nt">-o</span> 10
75545.821326 transactions / sec
</code></pre></div></div>

<p>Um – yeah. For all but the last case with 200 total threads, <em>the speed is slower</em>. However, look at the last run. It is <em>MUCH</em> faster than the same runs for Solution 1 and Solution 2.</p>

<p>This exercise illustrates an important point in performance debugging. What might be fast at a small scale is really slow at a larger scale. Similarly, optimizations for the large scale may make things worse at a small scale. You have been warned.</p>

<p>In this case, however, the likely situation is that you have many more clients than traders. Let’s see how they compare in that case.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MossPiglet% ./market3 <span class="nt">-c</span> 1000 <span class="nt">-t</span> 10 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 10
68965.526313 transactions / sec

./market2 <span class="nt">-c</span> 1000 <span class="nt">-t</span> 10 <span class="nt">-q</span> 10000 <span class="nt">-s</span> 1 <span class="nt">-o</span> 10
</code></pre></div></div>

<p>That’s right, market2 doesn’t finish. In fact, it pretty much kills my laptop. I’m afraid to try market1. Seriously.</p>

<h2 id="for-your-personal-enjoyment">For your Personal Enjoyment</h2>

<p>So far, in these examples, we haven’t focuses on the number of stocks in the market. That is, in each case, I’ve tested the system with only one stock that clients and traders manipulate (the <em>-s</em> parameter is <em>1</em>). It could be that there is additional performance to be gained by using a lock for each stock instead of a global lock on the whole market. <a href="https://www.gaeblog.com/assets/market4.c">Here is the full source code for a solution that uses a separate lock per stock</a>.</p>

<p>We’ll leave the analysis of this code to you as an exercise that might prove both helpful and informative (especially as you prepare for the midterm and final in this class). Does it make the code even faster?</p>

<h2 id="a-brief-word-about-monitors">A brief word about monitors</h2>

<p>Condition variables were originally proposed as part of an operating system concept called a <strong>monitor</strong>. The concept is a little like mutual exclusion, but with some important differences. Specifically:</p>

<ul>
  <li>at most one thread can be in the monitor at a time (like a critical section)</li>
  <li>while in the monitor it is possible for a thread to determine that it must wait for some condition to occur, in which case it leaves the monitor and goes on a queue waiting to get back in</li>
  <li>when a thread in the monitor satisfies a condition upon which other threads may be waiting, it signals one of those threads to unblock and <em>attempt</em> to re-enter the monitor</li>
  <li>when a thread leaves the monitor (either because it has finished its work in the monitor or because it is waiting), if there are threads waiting to enter (either from the beginning or because they have been signaled) the monitor selects one and admits it.</li>
</ul>

<p>This idea is an old one and there have been many variations (more than one thread allowed in the monitor, threads signaled are given priority over those trying to get in, the signaler leaves and waits to come back in, etc.) but these don’t change its essential functionality.</p>

<p>To see why condition variables in threads correspond to monitors, consider the way in which the client and trader threads syncronize in the examples.</p>

<p>A client thread, for example, tries to enter “the monitor” when it attempts to take the mutex lock. Either it is blocked (because some other client or trader thread is in the monitor) or it is allowed to proceed. If the queue is full, the client thread leaves the monitor but waits (on some kind of hidden queue maintained by pthreads) for the full condition to clear.</p>

<p>When a trader thread clears the full condition, it must be in the monitor (it has the queue locked) and it signals the condition variable. The pthreads implementation selects a thread from the hidden queue attached to that variable and allows it to try and re-enter the monitor by re-locking the lock.</p>

<p>Now, hopefully, it becomes clearer as to why the codes must retest once they have been awoken from a wait. Pthreads lets a thread that has been signaled try and retake the mutex lock that is passed to the wake call. For a monitor, this lock controls entry into the monitor and there may be other threads waiting on this lock to enter for the first time. If the lock protocol is FIFO, then one of these other threads may enter before the thread that has been awoken (it remains blocked). Eventually, though, it will be allowed to take the lock (it will get to the head of the lock’s FIFO) but by that time, the condition may have changed.</p>

<p>This subtlety trips up many a pthreads programmer. Once you understand it in terms of a monitor with one shared mutex and several conditions that use the mutex, it makes more sense (at least to me).</p>

        </article>
        <hr>

        
        
            
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2017/06/08/Race-Conditions/">Race Conditions</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/2017/06/08/Semaphore/">Semaphore</a></p>
        
    </div>
</div>


        <h2 id="comments">Comments</h2>
        


<div id="disqus_thread"></div>
<script>
    /**
     * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function() {
        this.page.url = 'https://www.gaeblog.com/2017/06/08/Condition-Variables/'; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://www.gaeblog.com/2017/06/08/Condition-Variables/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };

    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document,
            s = d.createElement('script');

        s.src = '//https-seraphroy-github-io-1.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>




    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

             <div class="side content" id="search-div">
                 <div>
    <i class="fa fa-search"></i>
    Search
</div>
<div id="site_search">
    <input type="text" id="search_box" placeholder="Search..." >
</div>
<div id="search_results"></div>

<link rel="stylesheet" type="text/css" href="https://www.gaeblog.com/assets/stylesheets/main.css">
<script type="text/javascript" src="https://www.gaeblog.com/assets/js/search.js"></script>
<script type="text/javascript" src="https://www.gaeblog.com/assets/js/node_modules/simpleblogsearch/index.js"></script>

<script>
SimpleBlogSearch({
   searchDataPath: '/assets/search_data.json',
   dataType: 'json',
   processDataFunc: function(data){ return data },
   searchInputID: 'search_box',
   resultsDivID: 'search_results',
   resultULClass: 'content-ul search-ul content-side',
   highlightKeywordClass: 'search_keyword',
   limit: 4,

});
</script>

             </div>
            <!-- Content -->
            <div class="side content">
                <div>
                    Content
                </div>
                <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#introduction--the-bounded-buffer-problem">Introduction – The Bounded Buffer Problem</a></li>
<li class="toc-entry toc-h2"><a href="#the-clienttrader-example">The Client/Trader Example</a></li>
<li class="toc-entry toc-h2"><a href="#example-solutions">Example Solutions</a>
<ul>
<li class="toc-entry toc-h3"><a href="#clients">Clients</a></li>
<li class="toc-entry toc-h3"><a href="#traders">Traders</a></li>
<li class="toc-entry toc-h3"><a href="#exectuting-the-examples">Exectuting the Examples</a></li>
<li class="toc-entry toc-h3"><a href="#understanding-the-examples">Understanding the Examples</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#solution-1-synchronization-using-mutexes-only">Solution 1: Synchronization using Mutexes Only</a>
<ul>
<li class="toc-entry toc-h3"><a href="#speed-of-solution-1">Speed of Solution 1</a></li>
<li class="toc-entry toc-h3"><a href="#the-effects-of-polling">The Effects of Polling</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#solution-2-synchronizing-the-order-queue-using-condition-variables">Solution 2: Synchronizing the Order Queue using Condition Variables</a>
<ul>
<li class="toc-entry toc-h3"><a href="#test-under-lock">Test under Lock</a></li>
<li class="toc-entry toc-h3"><a href="#summarizing-pthread_cond_wait-and-pthread_cond_signal">Summarizing pthread_cond_wait() and pthread_cond_signal()</a></li>
<li class="toc-entry toc-h3"><a href="#speed-of-solution-2">Speed of Solution 2</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#solution-3-using-a-condition-variable-to-signal-order-fulfillment">Solution 3: Using a condition variable to signal order fulfillment</a>
<ul>
<li class="toc-entry toc-h3"><a href="#speed-of-solution-3">Speed of Solution 3</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#for-your-personal-enjoyment">For your Personal Enjoyment</a></li>
<li class="toc-entry toc-h2"><a href="#a-brief-word-about-monitors">A brief word about monitors</a></li>
</ul>
                <ul id="content-side" class="content-ul">
                    
                    <li><a href="#comments">Comments</a></li>
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>
<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/assets/js/pageContent.js " charset="utf-8"></script>


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
            
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/SeraphRoy" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="mailto:royxagain@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>     
            <a href="https://www.facebook.com/SeraphRoy" title="Facebook"><i class="fa fa-facebook-official" aria-hidden="true"></i></a>   
            <a href="https://www.linkedin.com/in/yanxichen" title="LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i></a>  
        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /assets/js/main.js " charset="utf-8"></script>
    <script src=" /assets/js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /assets/js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
