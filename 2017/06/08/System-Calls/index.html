<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>System Calls</title>
    <meta name="description" content="  System CallsSystem CallsIn the C lecture we discussed the concept of separate compilation and C “libraries.” Functions like printf(), strlen() and strncpy(...">

    <link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="icon" href="/favicon.ico?" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://at.alicdn.com/t/font_8v3czwksspqlg14i.css">
    <link rel="stylesheet" href="/assets/stylesheets/main.css ">
    <link rel="canonical" href="https://www.gaeblog.com/2017/06/08/System-Calls/">
    <link rel="alternate" type="application/rss+xml" title="Gae Blog" href="https://www.gaeblog.com/assets/feed.xml ">



    <script>
    // google analytics
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-100686813-1', 'auto');
      ga('send', 'pageview');

    </script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    tex2jax: { inlineMath: [["$","$"],["\\(","\\)"]] },
    "HTML-CSS": {
      linebreaks: { automatic: true, width: "container" }
    }
});
</script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>System Calls | Gae Blog</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="System Calls" />
<meta name="author" content="Yanxi Chen" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="System Calls System Calls In the C lecture we discussed the concept of separate compilation and C “libraries.” Functions like printf(), strlen() and strncpy() are all implemented as libraries for Linux. That is, someone, some time wrote the following code (or something like it): int strlen(char *string) { int i; i = 0; while(string[i] != 0) { i++; } return(i); } That’s pretty much all strlen() does. As mentioned, this function is included as part of a default library called libc.a that is automatically linked with any C program (by default). There are some functions that your program also gets that are not implemented as libraries. Instead, these functions (which all must manipulate data structures that are shared among all processes in the system) are implemented directly by the operating system. That is, they act like they are loaded as part of a default library, but in fact they are part of the resident OS. These kinds of functions are called system calls because they are calls to the system (the OS). Knowing whether a Linux feature is implemented as a library or system call isn’t exactly easy. As a rule, the section section of the manual (section 2) are the basic system calls. If you type man 2 read you will see the system call read() listed, but type man 3 read and it won’t appear. However, man 3 fwrite shows the man page for the fwrite() library call. This isn’t a very satisfying or accurate way to determine whether a call is a default library call or a system call but it will get you started. Moreover, library calls like printf() may ultimately call system calls like write(). Finally, C was designed before dynamic linking of libraries was commonplace. As a result, before a program is fully loaded, the compiler may not be able to tell whether a call outside the program’s address space is to a library or a system call. Mostly you just need to read the developer documentation to determine what are the system calls that are available in any specific version of Linux (because they change from version to version). We’ll discuss a few system calls that are almost assured implemented in any version of Linux as system calls and not libraries." />
<meta property="og:description" content="System Calls System Calls In the C lecture we discussed the concept of separate compilation and C “libraries.” Functions like printf(), strlen() and strncpy() are all implemented as libraries for Linux. That is, someone, some time wrote the following code (or something like it): int strlen(char *string) { int i; i = 0; while(string[i] != 0) { i++; } return(i); } That’s pretty much all strlen() does. As mentioned, this function is included as part of a default library called libc.a that is automatically linked with any C program (by default). There are some functions that your program also gets that are not implemented as libraries. Instead, these functions (which all must manipulate data structures that are shared among all processes in the system) are implemented directly by the operating system. That is, they act like they are loaded as part of a default library, but in fact they are part of the resident OS. These kinds of functions are called system calls because they are calls to the system (the OS). Knowing whether a Linux feature is implemented as a library or system call isn’t exactly easy. As a rule, the section section of the manual (section 2) are the basic system calls. If you type man 2 read you will see the system call read() listed, but type man 3 read and it won’t appear. However, man 3 fwrite shows the man page for the fwrite() library call. This isn’t a very satisfying or accurate way to determine whether a call is a default library call or a system call but it will get you started. Moreover, library calls like printf() may ultimately call system calls like write(). Finally, C was designed before dynamic linking of libraries was commonplace. As a result, before a program is fully loaded, the compiler may not be able to tell whether a call outside the program’s address space is to a library or a system call. Mostly you just need to read the developer documentation to determine what are the system calls that are available in any specific version of Linux (because they change from version to version). We’ll discuss a few system calls that are almost assured implemented in any version of Linux as system calls and not libraries." />
<link rel="canonical" href="https://www.gaeblog.com/2017/06/08/System-Calls/" />
<meta property="og:url" content="https://www.gaeblog.com/2017/06/08/System-Calls/" />
<meta property="og:site_name" content="Gae Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-08T15:16:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="System Calls" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Yanxi Chen"},"description":"System Calls System Calls In the C lecture we discussed the concept of separate compilation and C “libraries.” Functions like printf(), strlen() and strncpy() are all implemented as libraries for Linux. That is, someone, some time wrote the following code (or something like it): int strlen(char *string) { int i; i = 0; while(string[i] != 0) { i++; } return(i); } That’s pretty much all strlen() does. As mentioned, this function is included as part of a default library called libc.a that is automatically linked with any C program (by default). There are some functions that your program also gets that are not implemented as libraries. Instead, these functions (which all must manipulate data structures that are shared among all processes in the system) are implemented directly by the operating system. That is, they act like they are loaded as part of a default library, but in fact they are part of the resident OS. These kinds of functions are called system calls because they are calls to the system (the OS). Knowing whether a Linux feature is implemented as a library or system call isn’t exactly easy. As a rule, the section section of the manual (section 2) are the basic system calls. If you type man 2 read you will see the system call read() listed, but type man 3 read and it won’t appear. However, man 3 fwrite shows the man page for the fwrite() library call. This isn’t a very satisfying or accurate way to determine whether a call is a default library call or a system call but it will get you started. Moreover, library calls like printf() may ultimately call system calls like write(). Finally, C was designed before dynamic linking of libraries was commonplace. As a result, before a program is fully loaded, the compiler may not be able to tell whether a call outside the program’s address space is to a library or a system call. Mostly you just need to read the developer documentation to determine what are the system calls that are available in any specific version of Linux (because they change from version to version). We’ll discuss a few system calls that are almost assured implemented in any version of Linux as system calls and not libraries.","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gaeblog.com/2017/06/08/System-Calls/"},"@type":"BlogPosting","headline":"System Calls","dateModified":"2017-06-08T15:16:00+00:00","datePublished":"2017-06-08T15:16:00+00:00","url":"https://www.gaeblog.com/2017/06/08/System-Calls/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>

    <header id="top">
    <div class="wrapper">
        <a href="/" class="brand">Gae Blog</a>
        <small>Software Engineer@Amazon</small>
        <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button>
        <nav id="headerNav">
            <ul>
                <li>
                    
                    <a href="/">
                    
                        <i class="fa fa-home"></i>Home
                    </a>
                </li>

                
                    
                    <li>
                        
                        <a href="/about/">
                        
                            <i class="fa fa-heart"></i>About
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                    <li>
                        
                        <a href="/archive/">
                        
                            <i class="fa fa-archive"></i>Archives
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/category/">
                        
                            <i class="fa fa-th-list"></i>Categories
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/tag/">
                        
                            <i class="fa fa-tags"></i>Tags
                        </a>
                    </li>
                    
                
                    
                    <li>
                        
                        <a href="/search/">
                        
                            <i class="fa fa-search"></i>Search
                        </a>
                    </li>
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </nav>
    </div>
</header>


        <div class="page clearfix" post>
    <div class="left">
        <h1>System Calls</h1>
        <div class="label">

            <div class="label-card">
                <i class="fa fa-calendar"></i>2017-06-08
            </div>

            <div class="label-card">
                <i class="fa fa-user"></i>Yanxi Chen
                
            </div>

            <div class="label-card">
                
            </div>

            <div class="label-card">
            


<!-- <span class="point">•</span> -->
<span class="categories">
  <i class="fa fa-th-list"></i>
  
    
        <a href="/category/#Operating System" title="Category: Operating System" rel="category">Operating System</a>
    
  

  <!-- <span class="point">•</span> -->
</span>


            </div>

            <div class="label-card">
            
<!-- <span class="point">•</span> -->
<span class="pageTag">
  <i class="fa fa-tags"></i>
  
    
        <!--a href="/tag/#Syscall" title="Tag: Syscall" rel="tag">Syscall</a-->
        <a href="/tag/#Syscall" title="Tag: Syscall" rel="tag">Syscall</a>
    
  

</span>

            </div>

        </div>
        <hr>
        <article itemscope itemtype="http://schema.org/BlogPosting">
        <ul id="markdown-toc">
  <li><a href="#system-calls" id="markdown-toc-system-calls">System Calls</a>    <ul>
      <li><a href="#getting-the-process-identifier" id="markdown-toc-getting-the-process-identifier">Getting the process identifier</a></li>
    </ul>
  </li>
  <li><a href="#files" id="markdown-toc-files">Files</a>    <ul>
      <li><a href="#reading-the-data-back" id="markdown-toc-reading-the-data-back">Reading the data back</a></li>
      <li><a href="#seeking-to-an-offset" id="markdown-toc-seeking-to-an-offset">Seeking to an offset</a></li>
      <li><a href="#standard-in-standard-out-and-standard-error" id="markdown-toc-standard-in-standard-out-and-standard-error">Standard In, Standard Out and Standard Error</a></li>
    </ul>
  </li>
  <li><a href="#forkexecwait" id="markdown-toc-forkexecwait">Fork/Exec/Wait</a>    <ul>
      <li><a href="#fork" id="markdown-toc-fork">Fork</a></li>
      <li><a href="#exec" id="markdown-toc-exec">Exec</a></li>
      <li><a href="#night-of-the-living-dead" id="markdown-toc-night-of-the-living-dead">Night of the Living Dead</a></li>
    </ul>
  </li>
  <li><a href="#pipes" id="markdown-toc-pipes">Pipes</a>    <ul>
      <li><a href="#putting-it-all-together" id="markdown-toc-putting-it-all-together">Putting It All Together</a></li>
    </ul>
  </li>
</ul>

<h2 id="system-calls">System Calls</h2>

<p>In the C lecture we discussed the concept of separate compilation and C “libraries.” Functions like <em>printf()</em>, <em>strlen()</em> and <em>strncpy()</em> are all implemented as libraries for Linux. That is, someone, some time wrote the following code (or something like it):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">strlen</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That’s pretty much all <em>strlen()</em> does. As mentioned, this function is included as part of a default library called <em>libc.a</em> that is automatically linked with any C program (by default).</p>

<p>There are some functions that your program also gets that are not implemented as libraries. Instead, these functions (which all must manipulate data structures that are shared among all processes in the system) are implemented <strong>directly by the operating system</strong>. That is, they act like they are loaded as part of a default library, but in fact they are part of the resident OS. These kinds of functions are called <strong>system calls</strong> because they are calls to the system (the OS).</p>

<p>Knowing whether a Linux feature is implemented as a library or system call isn’t exactly easy. As a rule, the section section of the manual (section 2) are the basic system calls. If you type</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man 2 <span class="nb">read</span>
</code></pre></div></div>

<p>you will see the system call <em>read()</em> listed, but type</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man 3 <span class="nb">read</span>
</code></pre></div></div>

<p>and it won’t appear. However,</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man 3 fwrite
</code></pre></div></div>

<p>shows the man page for the <em>fwrite()</em> library call.</p>

<p>This isn’t a very satisfying or accurate way to determine whether a call is a default library call or a system call but it will get you started. Moreover, library calls like <em>printf()</em> may ultimately call system calls like <em>write()</em>. Finally, C was designed before dynamic linking of libraries was commonplace. As a result, before a program is fully loaded, the compiler may not be able to tell whether a call outside the program’s address space is to a library or a system call.</p>

<p>Mostly you just need to read the developer documentation to determine what are the system calls that are available in any specific version of Linux (because they change from version to version). We’ll discuss a few system calls that are almost assured implemented in any version of Linux as system calls and not libraries.</p>

<!--more-->

<h3 id="getting-the-process-identifier">Getting the process identifier</h3>

<p>All processes in Linux get a unique identifier of type <em>pid_t</em>. Printing the value of a <em>pid_t</em> turns out to a matter of some debate. Seriously. I’ll go fast and loose on these examples but someone may give you grief down the road for a specific Linux or Unix version.</p>

<p>The system call to get the process identifier under Linux is <em>getpid()</em>. If you type</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man getpid
</code></pre></div></div>

<p>you will see that you need to include <em>sys/types.h</em> to get the type specifier and <em>unistd.h</em> to get the right prototype for the compiler. It takes no arguments and returns a <em>pid_t</em>. Try it out using <a href="https://www.gaeblog.com/assets/sys-call1.c">sys-call1.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; sys/types.h &gt;
#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
</span>
<span class="cm">/*
 * call getpid() as an example system call
 */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">my_id</span><span class="p">;</span>

    <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"my process id is %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">my_id</span><span class="p">);</span>

        <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You’ll just have to trust me that <em>getpid()</em> is implemented as a system call. Only the OS can assign your process a process identifier so to get the identifier, your process must make a call to the OS to get it.</p>

<hr />

<h2 id="files">Files</h2>

<p>One of the key abstractions that Linux provides is the file system. We’ll talk in depth about how the file system works later in the class. However, from a C perspective it is important that you know how to use files (in their most basic form).</p>

<p>There are five system calls associated with files that you should understand as part of basic C and Linux:</p>

<ul>
  <li>open: opens a file specified by the first argument with the “mode” specified in the second argument, and the permissions specified in the third argument. Returns an integer &gt;= <em>0</em> when successful and negative when not.</li>
  <li>close: closes the file which both tells the OS that your process will no longer access the file (useful for managing internal OS state) and also prevents the file from being accessed further in the process due to a programming error.</li>
  <li>read: reads a specified number of bytes (third argument) from a file (first argument) into a buffer (second argument) at “the current offset.”</li>
  <li>write: writes a specified number of bytes (third argument), from a buffer (second argument) into a file (first argument) “at the current offset.”</li>
  <li>lseek: changes “the current offset.”Either this sounds straight forward or it doesn’t. In reality, like most things with Linux, it is neither.</li>
</ul>

<p>First, you are probably familiar with the notion of a file being visible in the file system when you run the Linux utility <em>ls</em>. Further, that file is uniquely specified by a path name – a string of directories, separated by the “/” character, indicating the path through a directory tree from the root to the file. Turns out that only <em>open()</em> takes a path to the file. Once the file is opened, it must be referred to in your program by its <strong>file descriptor</strong> which is an integer assigned by the OS when the file is opened. The exact usage will be come clear, but it is important to understand that when you want to do anything other than open a file, you don’t specify the path name, but instead you specify the file descriptor number that came back from the open on the file.</p>

<p>Secondly, the OS keeps a “current offset” from the beginning of the file for you while the file is open on a specific file descriptor. When the file is first opened, the offset is zero. Subsequent calls to <em>read()</em> and <em>write()</em> on the file descriptor cause the offset to advance. To make the offset “back up” you either need to close the file, re-open it, and then advance the offset with read calls (which are non-destructive) or use the <em>lseek()</em> call to set the offset to a specific number.</p>

<p>Let’s start by writing a program that takes a file name as an argument, creates the file, and writes an important and pitch message into it as a string. Consider the program code available in <a href="https://www.gaeblog.com/assets/file-create1.c">file-create1.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * open to create a file and write a string into it
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
     <span class="o">**</span><span class="kt">int</span> <span class="n">my_file_desc</span><span class="p">;</span><span class="o">**</span> 
    <span class="kt">char</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">write_buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">write_length</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"need to specify a file name as the first argument</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * zero out the buffer for the file name
     */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">file_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * copy the argument into a local buffer
     */</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>
    <span class="n">file_name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
     * try and open the file for creation
     */</span>
     <span class="o">**</span><span class="n">my_file_desc</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span><span class="o">**</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">my_file_desc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"failed to open %s for creation</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">file_name</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * file is open, write a string into it
     */</span>
    <span class="n">string</span> <span class="o">=</span> 
         <span class="s">"This program brought to you by the council for better C programming"</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">write_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">,</span><span class="n">string</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">));</span>

    <span class="n">write_length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">);</span>

     <span class="o">**</span><span class="n">w</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">,</span><span class="n">write_buffer</span><span class="p">,</span><span class="n">write_length</span><span class="p">);</span><span class="o">**</span> 

    <span class="k">if</span><span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="n">write_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"write didn't complete, w: %d, length: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">w</span><span class="p">,</span>
            <span class="n">write_length</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">close</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">);</span>

    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>First, try running it as</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./file-create1 ./foo.txt
</code></pre></div></div>

<p>Then, look in the current directory for a file called <em>foo.txt</em>. What does it contain? Now try:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./file-create1 /foo.txt
</code></pre></div></div>

<p>This attempt should fail because you tried to create a file called “foo.txt” in the root directory and you don’t have write permissions for that directory (hopefully).</p>

<p>Next, look at the line where <em>open()</em> is called in the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_file_desc</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>
</code></pre></div></div>

<p>This line says to open the file specified by the string contained in the array <em>file_name</em> when treating that string as a path in the file system. If you run it with <em>foo.txt</em> or <em>./foo.txt</em> it will use the current working directory as the place where you try and create <em>foo.txt</em>.</p>

<p>The second argument requires that you look at the man page for open</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man 2 open
</code></pre></div></div>

<p>The second argument to open specifies how you want the file opened. In this case, I specified that I wanted the file created if it doesn’t exist but simply opened if it did. I also specified that I wanted only to write the file. If I had tried to call <em>read</em> on <em>my_file_desc</em> at some point after the open, the read would fail.</p>

<p>Notice that if I run the program twice</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./file-create1 foo.txt
./file-create1 foo.txt
</code></pre></div></div>

<p>I still only get one copy of the file with one string in it. That’s because the <em>open()</em> sets the current offset to zero each time. When I run this program the first time, it creates <em>foo.txt</em>. Each time after that it just overwrites the file with exactly the same string.</p>

<p>The third argument says that I want to create the file with the permissions “600” – or RW for owner only. See</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man 2 <span class="nb">chmod</span>
</code></pre></div></div>

<p>for details on specifying permissions. It is possible to use constants for these instead of numbers but I think of them as numbers.</p>

<p>Finally, notice that the open returns an integer (the type of <em>my_file_desc</em> is <em>int</em>). That value is passed to <em>write()</em> to indicate which file I want to write. If the code had opened two different files, each would have a different file descriptor number. For example, as in <a href="https://www.gaeblog.com/assets/file-create2.c">file-create2.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * open to create a couple of files and write a strings into each
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd2</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">file_name1</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">file_name2</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">write_buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">write_length</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"need to specify two file names as the first and second arguments</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * zero out the buffers for the file names
     */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">file_name1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">file_name1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">file_name2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * copy the first argument into a local buffer
     */</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">file_name1</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name1</span><span class="p">));</span>
    <span class="n">file_name1</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
     * and the second
     */</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">file_name2</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name2</span><span class="p">));</span>
    <span class="n">file_name2</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
     * try and open the first file for creation
     */</span>
     <span class="o">**</span><span class="n">fd1</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file_name1</span><span class="p">,</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span><span class="o">**</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">fd1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"failed to open %s for creation</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">file_name1</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * and the second
     */</span>
     <span class="o">**</span><span class="n">fd2</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file_name2</span><span class="p">,</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_WRONLY</span><span class="p">,</span>  <span class="mo">0600</span><span class="p">);</span><span class="o">**</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">fd2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"failed to open %s for creation</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">file_name2</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd1</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * both files are open, write a string into first
     */</span>
    <span class="n">string</span> <span class="o">=</span> 
         <span class="s">"This program brought to you by the council for better C programming"</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">write_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">,</span><span class="n">string</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">));</span>

    <span class="n">write_length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">);</span>

     <span class="o">**</span><span class="n">w</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd1</span><span class="p">,</span><span class="n">write_buffer</span><span class="p">,</span><span class="n">write_length</span><span class="p">);</span><span class="o">**</span> 

    <span class="k">if</span><span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="n">write_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"write didn't complete, w: %d, length: %d in %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">w</span><span class="p">,</span>
            <span class="n">write_length</span><span class="p">,</span>
            <span class="n">file_name1</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd1</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd2</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * and the second
     */</span>
    <span class="n">string</span> <span class="o">=</span> <span class="s">"C programming is both nutritious and great tasting."</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">write_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">,</span><span class="n">string</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">));</span>

    <span class="n">write_length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">write_buffer</span><span class="p">);</span>

     <span class="o">**</span><span class="n">w</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span><span class="n">write_buffer</span><span class="p">,</span><span class="n">write_length</span><span class="p">);</span><span class="o">**</span> 

    <span class="k">if</span><span class="p">(</span><span class="n">w</span> <span class="o">!=</span> <span class="n">write_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"write didn't complete, w: %d, length: %d in %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">w</span><span class="p">,</span>
            <span class="n">write_length</span><span class="p">,</span>
            <span class="n">file_name2</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd1</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd2</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">close</span><span class="p">(</span><span class="n">fd1</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd2</span><span class="p">);</span>

    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>You should read through this example and notice that the two files are referenced with two different file descriptors.</p>

<h3 id="reading-the-data-back">Reading the data back</h3>

<p>Now let’s try reading the data back from a file, as in <a href="https://www.gaeblog.com/assets/file-read1.c">file-read1.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * open and read the contents of a file, printing them out as ascii
 * characters
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">my_file_desc</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">read_buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"need to specify a file name as the first argument</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * zero out the buffer for the file name
     */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">file_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * copy the argument into a local buffer
     */</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>
    <span class="n">file_name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
     * try and open the file for reading
     */</span>
     <span class="o">**</span><span class="n">my_file_desc</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">O_RDONLY</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="o">**</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">my_file_desc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"failed to open %s for reading</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">file_name</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">read_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

     <span class="o">**</span><span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">,</span><span class="n">read_buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="o">**</span> 

    <span class="n">printf</span><span class="p">(</span><span class="s">"file: %s contains the string: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">file_name</span><span class="p">,</span>
        <span class="n">read_buffer</span><span class="p">);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">);</span>

    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Here the open call is a little different:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">my_file_desc</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">O_RDONLY</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>indicating that the file is to be open for reading only. The permissions will be checked but no permissions need to be specified since the file will not be created if it it isn’t present already.</p>

<p>Also, the read is a little different</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">,</span><span class="n">read_buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>In the case of <em>read()</em> the system call will read bytes up to the number specified in the third argument. If there are fewer than that number of bytes, it will return the ones it read and leave the current offset at the end of the file. Another read at the end will return a zero indicating that the file is empty.</p>

<p>If you wanted to read the entire contents of the file, then you will need to loop until there is no more data as in <a href="https://www.gaeblog.com/assets/file-read2.c">file-read2.c</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * read the file in its entirety (like the cat utility)
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">my_file_desc</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">read_buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"need to specify a file name as the first argument</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * zero out the buffer for the file name
     */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">file_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * copy the argument into a local buffer
     */</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>
    <span class="n">file_name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
     * try and open the file for reading
     */</span>
    <span class="n">my_file_desc</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">O_RDONLY</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">my_file_desc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"failed to open %s for reading</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">file_name</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">read_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
     <span class="o">**</span><span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">,</span><span class="n">read_buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="cm">/*
     * read and print until EOF
     */</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span><span class="n">read_buffer</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">read_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">,</span><span class="n">read_buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><span class="o">**</span> 
    <span class="n">close</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">);</span>

    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>This is essentially what the Linux utility <em>cat</em> does although cat probably does it in a more elegant way. Try it out on a text file that is bigger than 4K bytes to assure yourself that it works correctly.</p>

<p>For example, try</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./file-read2 /cs/faculty/rich/public_html/class/cs170/notes/C/index.html
</code></pre></div></div>

<p>and see if you get the text from the HTML for this web page back.</p>

<h3 id="seeking-to-an-offset">Seeking to an offset</h3>

<p>The <em>lseek()</em> system call moves the current offset pointer by the number of bytes specified from a starting location that is taken from its third argument. For example, consider <a href="https://www.gaeblog.com/assets/file-seek1.c">file-seek1.c</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * seek the file in the first argument to the location specified in the
 * second
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">my_file_desc</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">read_buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
    <span class="kt">off_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kt">off_t</span> <span class="n">where</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"need to specify a file name and an offset</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * zero out the buffer for the file name
     */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">file_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * copy the argument into a local buffer
     */</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>
    <span class="n">file_name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
     * get the offset from the second argument
     */</span>
     <span class="o">**</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">off_t</span><span class="p">)</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span><span class="o">**</span> 

    <span class="cm">/*
     * try and open the file for reading
     */</span>
    <span class="n">my_file_desc</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">O_RDONLY</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">my_file_desc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"failed to open %s for reading</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">file_name</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * seek to the offset specified in the second argument
     */</span>
     <span class="o">**</span><span class="n">where</span> <span class="o">=</span> <span class="n">lseek</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">,</span><span class="n">offset</span><span class="p">,</span><span class="n">SEEK_SET</span><span class="p">);</span><span class="o">**</span> 

    <span class="k">if</span><span class="p">(</span><span class="n">where</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"lseek to %d in file %s failed</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">file_name</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">read_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
     <span class="o">**</span><span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">,</span><span class="n">read_buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="cm">/*
     * read and print until EOF
     */</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span><span class="n">read_buffer</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">read_buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">,</span><span class="n">read_buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span><span class="o">**</span> 
    <span class="n">close</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">);</span>

    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>The line</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">where</span> <span class="o">=</span> <span class="n">lseek</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">,</span><span class="n">offset</span><span class="p">,</span><span class="n">SEEK_SET</span><span class="p">);</span>
</code></pre></div></div>

<p>after the call to <em>open()</em> but before the first call to <em>read()</em> moves the current offset to the byte offset specified in the second argument. The <em>SEEK_SET</em> parameter says to “set” the offset to the value specified (as opposed to setting it relative to the current offset). To see other options for this parameter, check out the man page.</p>

<p>Now try running the following:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./file-create1 foo.txt
./file-seek1 foo.txt 10
</code></pre></div></div>

<p>You should see something like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>am brought to you by the council for better C programming
</code></pre></div></div>

<p>where the first 10 bytes of the line are missing from the line in the file <em>foo.txt</em>. Does this make sense as the output?</p>

<h3 id="standard-in-standard-out-and-standard-error">Standard In, Standard Out and Standard Error</h3>

<p>Take a look at the code in <a href="https://www.gaeblog.com/assets/file-fd1.c">file-fd1.c</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * print out some file descriptors
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">my_file_desc</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"need to specify a file name</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * zero out the buffer for the file name
     */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">file_name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*
     * copy the argument into a local buffer
     */</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>
    <span class="n">file_name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*
     * try and open the file for reading
     */</span>
     <span class="o">**</span><span class="n">my_file_desc</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">O_RDONLY</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="o">**</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">my_file_desc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"failed to open %s for reading</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">file_name</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"my_file_desc: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_file_desc</span><span class="p">);</span>

    <span class="n">string</span> <span class="o">=</span> <span class="s">"a string written to standard out</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
     <span class="o">**</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">string</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">));</span><span class="o">**</span> 

    <span class="n">close</span><span class="p">(</span><span class="n">my_file_desc</span><span class="p">);</span>

    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>It should look a little alarming to you especially with respect to the <em>write()</em> call. Try running it after creating the file <em>foo.txt</em>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./file-create1 foo.txt
./file-fd1 foo.txt 
my_file_desc: 3
a string written to standard out
</code></pre></div></div>

<p>What happened here? First, notice that the value of file descriptor returned by the open call and stored in the integer variable <em>my_file_desc</em> is <em>3</em>. Turns out that this number is not just a random integer selected by Linux. Next, and perhaps most curiously, in the code the call to <em>write()</em> writes a string out to file descriptor that wasn’t opened.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">string</span> <span class="o">=</span> <span class="s">"a string written to standard out</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">string</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">));</span>
</code></pre></div></div>

<p>In fact, it is just writing to file descriptor <em>1</em> without any other reference to <em>1</em> as a file descriptor.</p>

<p>Linux automatically “opens” three file descriptors – <em>0, 1, and 2</em> for you when a process is launched and connects these file descriptors to the keyboard and the terminal. This feature explains the first line of output in that the smallest file descriptor that can be returned from a call to <em>open()</em> is <em>3</em> since file descriptors <em>0, 1, and 2</em> are already opened. Linux could have chosen any other integer when it chose a file descriptor for the call to <em>open()</em> in the code. For various historical reasons it will choose the smallest unused file descriptor. When the program launches, that file descriptor number will be <em>3</em>. If another call to open were made, that file descriptor would be <em>4</em>. If <em>close()</em> is called on <em>my_file_desc</em> and then open is called again, <em>3</em> will be chosen since at that moment it would be the smallest unused file descriptor.</p>

<p>The three “special” file descriptors Linux opens for you at process launch are</p>

<ul>
  <li>File descriptor <em>0</em>: connected to the keyboard and is referred to as <strong>standard in</strong>.</li>
  <li>File descriptor <em>1</em>: connected to the terminal and is referred to as <strong>standard out</strong></li>
  <li>File descriptor <em>2</em>: also connected to the terminal and is referred to as <strong>standard error</strong>The last two are separated so that the shell can send errors to the terminal even if you redirect the standard output to a file.</li>
</ul>

<p>Thus, the call to write tells the OS to write from the string buffer the <em>strlen()</em> of the string to the standard out device which (unless you closed it) will be the terminal. Notice that the call to <em>write()</em> doesn’t know whether the destination is standard out or a file – it just writes the data to the file that the OS has associated with the file descriptor and that “file” has cleverly been impersonated by the terminal.</p>

<p>To see the difference between <strong>standard out</strong> and <strong>standard error</strong> try running the code in <a href="https://www.gaeblog.com/assets/file-fd2.c">file-fd2.c</a></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * print out some file descriptors
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string_err</span><span class="p">;</span>

    <span class="n">string</span> <span class="o">=</span> <span class="s">"a string written to standard out</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
     <span class="o">**</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">string</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">));</span><span class="o">**</span> 

    <span class="n">string_err</span> <span class="o">=</span> <span class="s">"a string written to standard error</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
     <span class="o">**</span><span class="n">write</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">string_err</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">string_err</span><span class="p">));</span><span class="o">**</span> 

    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>First, run it from the terminal and then run it, but redirect (using the shell) the output to a file:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./file-fd2
a string written to standard out
a string written to standard error

./file-fd2 <span class="o">&gt;</span> fd2.out
a string written to standard error
<span class="nb">cat </span>fd2.out
a string written to standard out
</code></pre></div></div>

<p>In the first execution, both standard out and standard error were sent to the terminal. In the second, standard out the shell opened a file and sent the output on standard out to the file. The <em>&gt;</em> operator in the shell implements this file writing function. However standard error was not redirected so the string written on file descriptor <em>2</em> was sent to the terminal.</p>

<p>Standard in works the same way, but it needs to know when there is no more input from the keyboard. When you tun the code in <a href="https://www.gaeblog.com/assets/file-fd3.c">file-fd3.c</a></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * read from stdin and write to stdout
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

    <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">buffer</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Notice that this codes uses the function <em>memset()</em> to zero out the buffer. It reads up tot he buffer’s size from standard in (the keyboard) and then writes it to the terminal. However, when you run the program, you need to type the character <em>ctrl-D</em> before the program will finish. Otherwise, it waits, blocked in the read call, waiting for another character.</p>

<p>I ran it, types the characters in <em>my dog is happy!</em> and then <em>ctrl-D</em>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./file-fd3
my dog is happy!my dog is happy!
</code></pre></div></div>

<p>The <em>ctrl-D</em> character tells the shell that the end of file has been reached which, for standard in means that no more characters will be coming from the keyboard. The program then writes the wring back out to standard out.</p>

<p>The shell can also redirect data from a file to standard in. Using the file from the previous example, try</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./file-fd3 &lt; fd2.out
</code></pre></div></div>

<p>which causes the contents fo the file <em>fd2.out</em> to be sent to standard in of <em>file-fd3</em> until the end-of-file is reached. The read then terminates the data is written to standard out.</p>

<hr />

<h2 id="forkexecwait">Fork/Exec/Wait</h2>

<p>When you log into a Linux system and you get a prompt, the program that is running is called “the shell.” It is usually a BASH shell (see the man page) and its job is to create processes on your behalf. Some of those processes then run Linux utilities for you. For example, when you type</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> ~
</code></pre></div></div>

<p>you are telling the shell to run a program called <em>ls</em> (which is located in the /usr/bin directory) and to pass it, as its first argument, the path to your home directory. The shell expands the <em>~</em> character into a path, but <em>ls</em> is a C program that someone wrote for your Linux system. It was compiled when your Linux was built and it is placed in /usr/bin when Linux is installed. The shell looks in a few places (defined by the PATH environment variable) for programs to run when you simply give their names, like I have in this example with <em>ls</em>.</p>

<p>But how does the shell (or any other C program since the shell, itself, is just a program written in C and compfile for Linux) create a process and run another program that has been compiled?</p>

<h3 id="fork">Fork</h3>

<p>The way one program runs another in Linux is a little odd. First, it makes an exact copy of itself using the <em>fork()</em> system call. When <em>fork()</em> completes, there are two copies of the same program. Then, the second copy calls <em>exec()</em> which loads the binary for the second program over itself and starts it from the beginning. I know. It gets easier once you see it.</p>

<p>Take a look at the code in <a href="https://www.gaeblog.com/assets/fork-1.c">fork-1.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * simple program calling fork
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">child_id</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">my_id</span><span class="p">;</span>

    <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am the parent about to call fork</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">);</span>

     <span class="o">**</span><span class="n">child_id</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I just forked a child with id %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">child_id</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am the child</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_id</span><span class="p">);</span>
    <span class="p">}</span><span class="o">**</span> 

    <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_id</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>The call to <em>fork()</em> creates an <strong>exact copy of the process calling fork except for the process identifier</strong> which is different since it is a new process. The interesting part is that this new process (typically called the <em>child</em> process) begins running at the instruction <strong>immediately after the fork() call in the program</strong>. That is, after the call to <em>fork()</em> completes, there are two processes running and they both execute the next line which is</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span>child_id <span class="o">!=</span> 0<span class="o">)</span> <span class="o">{</span>
</code></pre></div></div>

<p>which is pretty typical. The call to <em>fork()</em> returns the process identifier to of the newly created process to the parent, but returns zero to the child. That way the code can have the child and parent diverge and execute different code paths. In this example, the parent and child print different messages after the child has been forked. The output I get is</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./fork-1
pid: 40285 <span class="nt">--</span> I am the parent about to call fork
pid: 40285 <span class="nt">--</span> I just forked a child with <span class="nb">id </span>40286
pid: 40285 <span class="nt">--</span> I am exiting
pid: 40286 <span class="nt">--</span> I am the child
pid: 40286 <span class="nt">--</span> I am exiting
</code></pre></div></div>

<p>On each line, the code prints the process identifier of the process calling <em>printf()</em>. Thus the parent or origibal process is process <em>40285</em>. It creates a child process and Linux chooses <em>40286</em> for that process’ identifier which is returned from the call to <em>fork()</em> to the parent. The parent then prints a message indicating that it has created the child and the child prints a message with its identifier. Both then print before they exit.</p>

<p>The parent can wait for the child to complete using the <em>wait()</em> system call. Take a look at <a href="https://www.gaeblog.com/assets/fork-2.c">fork-2.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * simple program calling fork and wait
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">child_id</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">my_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">child_status</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">child_id</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I just forked a child with id %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">child_id</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am waiting for process %d to finish</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">child_id</span><span class="p">);</span>
         <span class="o">**</span><span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_status</span><span class="p">);</span><span class="o">**</span> 
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- my child has completed with status: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="n">child_status</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am the child and I am count to 10</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_id</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_id</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Running this version yields:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./fork-2
pid: 74869 <span class="nt">--</span> I just forked a child with <span class="nb">id </span>74870
pid: 74869 <span class="nt">--</span> I am waiting <span class="k">for </span>process 74870 to finish
pid: 74870 <span class="nt">--</span> I am the child and I am going to count to 10
pid: 74870 <span class="nt">--</span> 1
pid: 74870 <span class="nt">--</span> 2
pid: 74870 <span class="nt">--</span> 3
pid: 74870 <span class="nt">--</span> 4
pid: 74870 <span class="nt">--</span> 5
pid: 74870 <span class="nt">--</span> 6
pid: 74870 <span class="nt">--</span> 7
pid: 74870 <span class="nt">--</span> 8
pid: 74870 <span class="nt">--</span> 9
pid: 74870 <span class="nt">--</span> 10
pid: 74870 <span class="nt">--</span> I am exiting
pid: 74869 <span class="nt">--</span> my child has completed with status: 0
pid: 74869 <span class="nt">--</span> I am exiting
</code></pre></div></div>

<p>Notice the process identifiers. The parent waits until the child exits and then continues after it has done so.</p>

<p>Notice also that the call to <em>wait()</em> takes a pointer to an integer as a parameter. The <em>wait()</em> call uses this parameter as an out parameter to deliver an integer to the parent indicating the child’s exit status.</p>

<p>The exit status in the child is given in the argument to <em>exit()</em> which, in this example, is <em>0</em>. Most Linux utilities return an exit status of <em>0</em> when the complete successfully and a small positive integer (usually <em>1</em> or <em>2</em>) when an error has occured. If the call to exit had been</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>the parent would see the value of the integer variable <em>child_status</em> set to <em>1</em>. You should probably adopt this convention with respect to exit status (at least, as far as returning a <em>0</em> when everything went okay) because many if not most shell scripts use the exit status to determine if an error in some utility has occured.</p>

<h3 id="exec">Exec</h3>

<p>The <em>fork()</em> clones the running process, but often what you need is to execute (as its own process) a program that is located in a file in the file system.</p>

<p>While the function of <em>fork()</em> has remained relatively constant over the years, <em>exec()</em> has undergone a few changes since it was first defined. The version we will discuss is <em>execve()</em> since its definition is rather clear. To be complete, you should look at the man pages for</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>man 2 execve
man 2 execl
</code></pre></div></div>

<p>The latter call will decsribe different variants of <em>exec()</em> each of which has its own peculiarities. For example, when you give the filename of the program you wish to have loaded by <em>exec()</em> you may want the search path to be the same search path as the shell uses when it ran the program that is calling <em>exec()</em>. See the second man entry for details.</p>

<p>However, we will constrain our remarks to <em>execve()</em> for the sakes both of simplicity and brevity.</p>

<p>Consider the code contained in <a href="https://www.gaeblog.com/assets/fork-3.c">fork-3.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * run a program using fork and execve
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">child_id</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">my_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">child_status</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"must specify file name as first argument</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>

    <span class="n">child_id</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I forked pid: %d for: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">my_id</span><span class="p">,</span>
            <span class="n">child_id</span><span class="p">,</span>
            <span class="n">file_name</span><span class="p">);</span>
        <span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_status</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- %s has completed with status: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="n">file_name</span><span class="p">,</span>
            <span class="n">child_status</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am the child and I am going to exec %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="n">file_name</span><span class="p">);</span>
         <span class="o">**</span><span class="n">err</span> <span class="o">=</span> <span class="n">execve</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">envp</span><span class="p">);</span>
        <span class="cm">/*
         * not reached if execve is successful
         */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- execve of %s failed with error %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">**</span> 
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="n">file_name</span><span class="p">,</span>
            <span class="n">err</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_id</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>You should read this code carefully as it contains a few subtleties. First, notice that it forks a child and then the child calls <em>execve()</em> to run a program. The string <em>file_name</em> is used to tell <em>execve()</em> what program to run. Also, the parent program passes <em>&amp;(argv[1])</em> as the second argument to <em>execve()</em> and the environment pointer for the main program. Finally, notice that the error message is printed immediately after the call to <em>execve()</em> without testing to see if the value is non-zero.</p>

<p>Let’s take these observations one at a time.</p>

<p>The first argument to <em>execve()</em> really needs to be a path to the file in the file system that contains an executable program. Thus, it will need to contain something like <em>/bin/hostname</em> or <em>./fork-1</em> – a complete path name to the binary.</p>

<p>Next, <em>execve()</em> takes a list of arguments that it will pass (as the <em>char *argv[]</em> parameter) to the <em>main()</em> function of the program that is being run. In this example, the first argument passed to <em>fork-3</em> will be the path name to the binary to execute and the remaining arguments that need to be pass to it to do its job.</p>

<p>So, for example, to get <em>fork-3</em> to run <em>/bin/ls</em> on the <em>/tmp</em> directory you would execute</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./fork-3 /bin/ls /tmp
</code></pre></div></div>

<p>and <em>/tmp</em> will need to be passed to <em>/bin/ls</em> through the call to <em>execve()</em>. Further, like argv in the parent, the <em>argv[0]</em> passed to the program that is being run must be the path name of the binary. Think about this for a minute. It will make sense after a bit.</p>

<p>Try a few examples:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./fork-3 /bin/date
pid: 75976 <span class="nt">--</span> I forked pid: 75977 <span class="k">for</span>: /bin/date
pid: 75977 <span class="nt">--</span> I am the child and I am going to <span class="nb">exec</span> /bin/date
Wed Jan 14 15:01:23 PST 2015
pid: 75976 <span class="nt">--</span> /bin/date has completed with status: 0
pid: 75976 <span class="nt">--</span> I am exiting
</code></pre></div></div>

<p>Take a look at the process identifiers. Notice that the parent forks the child and waits, the child calls <em>execve()</em> and when <em>/bin/date</em> has completed, the parent unblocks from its call to <em>wait()</em> getting back the exit status generated by <em>/bin/date</em>.</p>

<p>Notice also that the message immediately after the call to <em>execve()</em> in the child is <strong>not</strong> printed. That’s because if the call to <em>execve()</em> is successful, the child is <strong>completely overwritten</strong> by the new code and, thus, stops executing its own code. If the call to <em>execve()</em> fails, however, then the child continues to execute. For example,</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./fork-3 <span class="nb">date
</span>pid: 76043 <span class="nt">--</span> I forked pid: 76044 <span class="k">for</span>: <span class="nb">date
</span>pid: 76044 <span class="nt">--</span> I am the child and I am going to <span class="nb">exec date
</span>pid: 76044 <span class="nt">--</span> execve of <span class="nb">date </span>failed with error <span class="nt">-1</span>
pid: 76044 <span class="nt">--</span> I am exiting
pid: 76043 <span class="nt">--</span> <span class="nb">date </span>has completed with status: 0
pid: 76043 <span class="nt">--</span> I am exiting
</code></pre></div></div>

<p>Here, the path name to <em>/bin/date</em> is not fully specified. The system call <em>execve()</em> does not use the <em>$PATH</em> environment variable to determine what to run. The simply specifying <em>date</em> causes <em>execve()</em> to fail because it can’t find <em>date</em> in the file system. Try it with <em>/usr/date</em></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./fork-3 /usr/date
pid: 76096 <span class="nt">--</span> I forked pid: 76097 <span class="k">for</span>: /usr/date
pid: 76097 <span class="nt">--</span> I am the child and I am going to <span class="nb">exec</span> /usr/date
pid: 76097 <span class="nt">--</span> execve of /usr/date failed with error <span class="nt">-1</span>
pid: 76097 <span class="nt">--</span> I am exiting
pid: 76096 <span class="nt">--</span> /usr/date has completed with status: 0
pid: 76096 <span class="nt">--</span> I am exiting
</code></pre></div></div>

<p>and it fails the same way because there is no file called <em>date</em> in <em>/usr</em>.</p>

<p>Now try it with <em>/bin/ls</em></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./fork-3 /bin/ls <span class="nt">-al</span> fork-3.c
pid: 76113 <span class="nt">--</span> I forked pid: 76114 <span class="k">for</span>: /bin/ls
pid: 76114 <span class="nt">--</span> I am the child and I am going to <span class="nb">exec</span> /bin/ls
<span class="nt">-rw-r--r--</span>  1 rich  staff  1118 Jan 14 14:52 fork-3.c
pid: 76113 <span class="nt">--</span> /bin/ls has completed with status: 0
pid: 76113 <span class="nt">--</span> I am exiting
</code></pre></div></div>

<p>Compare that output to</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/bin/ls <span class="nt">-al</span> fork-3.c
<span class="nt">-rw-r--r--</span>  1 rich  staff  1118 Jan 14 14:52 fork-3.c
</code></pre></div></div>

<p>Nifty. In fact, <em>fork-3</em> is doing what <em>/bin/bash</em> does when you tell the shell to run <em>/bin/ls</em> – it is more or less the same logic.</p>

<p>Oh-oh. Buckle up.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MossPiglet% ./fork-3 /bin/bash
pid: 76193 <span class="nt">--</span> I forked pid: 76194 <span class="k">for</span>: /bin/bash
pid: 76194 <span class="nt">--</span> I am the child and I am going to <span class="nb">exec</span> /bin/bash
MossPiglet%
</code></pre></div></div>

<p>What happened here? It started running bash and bash is blocked waiting for my input. Notice that the parent is still waiting for the child to exit. The child called <em>execve()</em> on <em>/bin/bash</em> and bash ran and is waiting for my input. If I type <em>exit</em> or <em>ctrl-D</em> that bash will exit, the parent will wake up, and <em>fork-3</em> will exit.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MossPiglet% ./fork-3 /bin/bash
pid: 76241 <span class="nt">--</span> I forked pid: 76242 <span class="k">for</span>: /bin/bash
pid: 76242 <span class="nt">--</span> I am the child and I am going to <span class="nb">exec</span> /bin/bash
MossPiglet% <span class="nb">exit
exit
</span>pid: 76241 <span class="nt">--</span> /bin/bash has completed with status: 0
pid: 76241 <span class="nt">--</span> I am exiting
</code></pre></div></div>

<p>Why did this work? Keep in mind that the child overwrote itself with the code from the executable binary located in the file <em>/bin/bash</em> but it <strong>inherits everything else from the parent</strong>. In particular, it gets the same open file descriptors and they remain open. What open file descriptors does bash need? Standard in, standard out, and standard error. Thus, bash gets the same standard in, standard out, and standard error that <em>fork-3</em> had and, thus, it works just fine as its own shell. Only when you call <em>exit</em> the <em>fork-3</em> process is waiting and it wakes up to get the exit status. Try it with a different status:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./fork-3 /bin/bash
pid: 76401 <span class="nt">--</span> I forked pid: 76402 <span class="k">for</span>: /bin/bash
pid: 76402 <span class="nt">--</span> I am the child and I am going to <span class="nb">exec</span> /bin/bash
MossPiglet% <span class="nb">exit </span>1
<span class="nb">exit
</span>pid: 76401 <span class="nt">--</span> /bin/bash has completed with status: 256
pid: 76401 <span class="nt">--</span> I am exiting
</code></pre></div></div>

<p>Whoops. Why did <em>256</em> come back as a status instead of <em>1</em>?</p>

<p>Turns out _wait()_encodes the exit status in the status integer. The correct way to manage it is depcited in <a href="https://www.gaeblog.com/assets/fork-4.c">fork-4.c</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
#include &lt; sys/wait.h &gt;
</span>
<span class="cm">/*
 * run a program using fork and execve
 * pring the status correctly
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">child_id</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">my_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">child_status</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"must specify file name as first argument</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>

    <span class="n">child_id</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I forked pid: %d for: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">my_id</span><span class="p">,</span>
            <span class="n">child_id</span><span class="p">,</span>
            <span class="n">file_name</span><span class="p">);</span>
        <span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_status</span><span class="p">);</span>
         <span class="o">**</span><span class="k">if</span><span class="p">(</span><span class="n">WIFEXITED</span><span class="p">(</span><span class="n">child_status</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- %s has completed with status: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
                <span class="n">file_name</span><span class="p">,</span>
                <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">child_status</span><span class="p">));</span>
        <span class="p">}</span><span class="o">**</span> 
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am the child and I am going to exec %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="n">file_name</span><span class="p">);</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">execve</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">envp</span><span class="p">);</span>
        <span class="cm">/*
         * not reached if execve is successful
         */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- execve of %s failed with error %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="n">file_name</span><span class="p">,</span>
            <span class="n">err</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_id</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Turns out that the parent will wake up on conditions other than the child exiting (like the child gets a signal). You can test to see why the child woke up with and if it exited gets its one byte of status using the <em>WIFEXITED()</em> and <em>WEXITSTATUS()</em> macros respectively. They com in the header file <em>sys/wait.h</em>. Consult the man pages for further details.</p>

<h3 id="night-of-the-living-dead">Night of the Living Dead</h3>

<p>This exit status processing can cause a bit of an issue. In fact, if the parent doesn’t call <em>wait()</em> and the child exits, Linux creates a <strong>zombie process</strong> which waits around for the parent <strong>only so that it can report its exit status</strong>. If the parent never calls <em>wait()</em>, the zombie never truly dies. It can’t do anything else, but Linux won’t clean up its process state until the parent calls <em>wait()</em>.</p>

<p>Or until the parent dies. When the parent of a child dies, the child is <em>usually</em> <strong>adopted</strong> by a special Linux process called <em>init</em>. Every running Linux system has an <em>init</em> process. After the system boots, the job of <em>init</em> is just to call <em>wait()</em> so that orphaned children can report their exit status and avoid becoming zombies, or cease to be zombies.</p>

<p>For example, a parent that creates a child and then goes into an infinite loop before calling <em>wait()</em> creates a zombie when that child exits. If you kill the parent with a <em>ctrl-C</em>, the zombie child will immediately be adopted by <em>init</em> which is calling <em>wait()</em>. The exit status will be reported to <em>init</em> (which discards it) and the zombie child finally dies completely. The <em>init</em> process goes back to waiting for other orphaned children.</p>

<p>Seriously.</p>

<p>Like with many of the original Unix semantics, this behavior (which dates to early versions of Unix) can be modified in the current implementation of Linux. The default behavior is for <em>init</em> to adopt all parentless children. However using the <strong>prctl()</strong> system call with the <strong>PR_SET_CHILD_SUBREAPER</strong> argument you can set a process to be available as an adopter of parentless children. When called all descendents of the process will inherit this process as their “reaper” should a parent die. In the event of a parent termination, the nearest anscestor in the process tree that is a subreaper for the descendents becomes the reaper. However if no subreapers are in the process tree, then <em>init</em> defaults to being th reaper.</p>

<p>Um. Yeah.</p>

<hr />

<h2 id="pipes">Pipes</h2>

<p>Pipes are a way for two processes to communicate. When you create a pipe, you give the <em>pipe()</em> system call an array of two integers that it uses as an out parameter. It allocates two file descriptors (one for reading and the other for writing). Any data written to the write file descriptor will be available for reading on the read file descriptor. If the read and and write ends are in separate processes, the transfers the data from the writer process to the reader process.</p>

<p>Because they are represented using file descriptors, the same <em>read()</em> and <em>write()</em> calls that work for files also work for pipes. You can’t call <em>lseek()</em> on them and you used the <em>pipe()</em> call to open then instead of calling <em>open()</em> but once they are set up, they behave like files from a usage perspective.</p>

<p>In <a href="https://www.gaeblog.com/assets/pipe-1.c">pipe-1.c</a>, the code opens a pipe, writes a string to the “write end”, and then reads the “read end” to get what ever is in the pipe (up to the size of the read buffer).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * simple program to create and use a pipe
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">pipe_desc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">read_buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

     <span class="o">**</span><span class="n">err</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">);</span><span class="o">**</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"error creating pipe</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">string</span> <span class="o">=</span> <span class="s">"a string"</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"writing %s to pipe_desc[1] which is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">string</span><span class="p">,</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">write</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">string</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">));</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"attempting to read pipe_desc[0] which is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">read</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">read_buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">));</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"read %s from pipe_desc[0]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">read_buffer</span><span class="p">);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>The code simply opens a pipe, writes a string into it using the <em>write()</em> system call and then reads the string back from the pipe.</p>

<p>There are a couple of subtlties here, though. First, while the write end “knows” how much data it will write, the read end doesn’t. In this example, I made the read buffer 4096 bytes in length. If the writer had written more than 4096 bytes, the reader would have only read the first 4096 <strong>assuming that the pipe is big enough to hold 4096 bytes</strong>. The semantics are that the pipe has some capacity (which is not known) and if the writing program exceeds that capacity it blocks under a reader has drained the pipe there by freeing some capacity.</p>

<p>In other words, a pipe is the Linux system call implementation of the bounded buffer problem we discussed in the <a href="http://www.cs.ucsb.edu/~rich/class/cs170/notes/CondVar/index.html">lecture on condition variables</a>. Notice that in this example, the process could “deadlock” itself by writing more into the pipe than the pipe can hold.</p>

<p>Pipes are really designed to be used between processes so having the writing process block until a reading process drains some of the data from the pipe is necessary.</p>

<p>Similarly, the reader of read end of the pipe will block if there is no data to read in the pipe. However, if and when the write end is closed, the read end will unblock and the read will read no data. This interaction between reading a pipe, blocking, and closing a pipe will become clearer as we look at pipes between processes. The easiest way to think of it, though, is to realize that the reader of a pipe waiting for data would wait forever if the writer died without a way to inform the reader that the write end will never produce more data.</p>

<p>Usually a pipe is established between processes that wish to communicate rather than within a single process (as in the previous example). In <a href="https://www.gaeblog.com/assets/pipe-2.c">pipe-2.c</a></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
#include &lt; sys/wait.h &gt;
</span>
<span class="cm">/*
 * simple program creating a pipe between two processes
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">child_id</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">my_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pipe_desc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">read_buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">child_status</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

    <span class="cm">/*
     * create the pipe
     */</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"error creating pipe</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * then fork
     */</span>
    <span class="n">child_id</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*
         * parent will be the writer
         * doesn't need the read end
         */</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="cm">/*
         * send the child a string
         */</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s">"a string made by the parent</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- writing %s to pipe_desc[1]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="n">string</span><span class="p">);</span>
         <span class="o">**</span><span class="n">write</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">string</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">));</span><span class="o">**</span> 
        <span class="cm">/*
         * close the pipe to let the read end know we are
         * done
         */</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="cm">/*
         * wait for the child to exit
         */</span>
        <span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_status</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/*
         * child reads the read end
         */</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="cm">/*
         * doesn't need the write end
         */</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">));</span>
         <span class="o">**</span><span class="n">read</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">read_buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">));</span><span class="o">**</span> 
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- received %s from parent</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
                <span class="n">read_buffer</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_id</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Notice that the code creates a pipe before it calls <em>fork()</em>. As a result, both the parent and child process have the pipe open on the same set of file descriptors. It is good programming practice to close the pipe descriptors in a process that are not being used. Thus, the parent closes the read end (because it writes in this example) and the child closes the write end (because it reads). The parent closes the pipe after the write and then waits for the child to exit.</p>

<p>To see the close of write end trigger the reading end to exit, take a look at the code in <a href="" example="" pipe-3.c="">pipe-3.c</a></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
</span>
<span class="cm">/*
 * simple program creating a pipe between two processes
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">child_id</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">my_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pipe_desc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">read_buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

    <span class="cm">/*
     * create the pipe
     */</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"error creating pipe</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * then fork
     */</span>
    <span class="n">child_id</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">child_id</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*
         * parent will be the writer
         * doesn't need the read end
         */</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="cm">/*
         * send the child a string
         */</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s">"a string made by the parent</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- writing %s to pipe_desc[1]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="n">string</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">string</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">));</span>
        <span class="cm">/*
         * and another string
         */</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s">"and another string"</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- writing %s to pipe_desc[1]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
            <span class="n">string</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">string</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">));</span>
         <span class="o">*</span><span class="err">*/</span><span class="o">*</span>
         <span class="o">*</span> <span class="n">fall</span> <span class="n">off</span> <span class="n">the</span> <span class="n">end</span> <span class="n">to</span> <span class="n">close</span>
         <span class="err">*/</span><span class="o">**</span> 
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/*
         * child will read until pipe closes
         * close the write end
         */</span>
        <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">));</span>
         <span class="o">**</span><span class="k">while</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">read_buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">)))</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- received %s from parent</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">,</span>
                <span class="n">read_buffer</span><span class="p">);</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">read_buffer</span><span class="p">));</span>
        <span class="p">}</span><span class="o">**</span> 
        <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- child detects write end closed</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">my_id</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"pid: %d -- I am exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_id</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Here, the child reads the pipe in a while loop looking for the read to complete with a value of zero (indicating end-of-file). When the parent closes the write end, the read end will deliver EOF <strong>after</strong> it has delivered what ever data is in the pipe. That is, the close and exit of the parent does not prevent the data in transit from being delivered.</p>

<p>The output</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./pipe-3
pid: 98839 <span class="nt">--</span> writing a string made by the parent
 to pipe_desc[1]
pid: 98839 <span class="nt">--</span> writing and another string to pipe_desc[1]
pid: 98839 <span class="nt">--</span> I am exiting
pid: 98840 <span class="nt">--</span> received a string made by the parent
and another string from parent
pid: 98840 <span class="nt">--</span> child detects write end closed
pid: 98840 <span class="nt">--</span> I am exiting
</code></pre></div></div>

<p>also shows the parent writing both strings and exiting before the child runs. The child gets both strings (but in one read call – not two) then detects the close of the write end as a zero rerturned from read (causing it to fall out of the while loop).</p>

<h3 id="putting-it-all-together">Putting It All Together</h3>

<p>At this point, you have enough to understand how to write a program that creates arbitrary chains of pipes that communicate via processes that use Standard In and Standard Out.</p>

<p>Consider the code in <a href="https://www.gaeblog.com/assets/my-cat.c">my-cat.c</a> which is a program that implements functionality similar to the Linux <em>cat</em> utility:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
#include &lt; string.h &gt;
</span>
<span class="cm">/*
 * simple program implementing cat
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">my_id</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

    <span class="n">my_id</span> <span class="o">=</span> <span class="n">getpid</span><span class="p">();</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"pid: %d -- I am my-cat and I have started</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_id</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

    <span class="k">while</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"pid: %d read some data</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">());</span>
        <span class="n">buffer</span><span class="p">[</span><span class="mi">4095</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* safety first */</span>
        <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">buffer</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"pid: %d wrote some data</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">getpid</span><span class="p">());</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"pid: %d -- I am my-cat and I am exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">my_id</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>It simply reads data from Standard In (that it assumes is string data) and echos it to Standard Out. It also prints a message when it starts and when it ends. If you run it from the command line</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./my-cat
pid: 33672 <span class="nt">--</span> I am my-cat and I have started
I love the OS class more than any other class!
pid: 33672 <span class="nb">read </span>some data
I love the OS class more than any other class!
pid: 33672 wrote some data
It is really great to know how to program <span class="k">in </span>C and to understand Linux!
pid: 33672 <span class="nb">read </span>some data
It is really great to know how to program <span class="k">in </span>C and to understand Linux!
pid: 33672 wrote some data
It is really great to know how to program <span class="k">in </span>C and to understand Linux!
pid: 33672 <span class="nb">read </span>some data
It is really great to know how to program <span class="k">in </span>C and to understand Linux!
pid: 33672 wrote some data
pid: 33672 <span class="nt">--</span> I am my-cat and I am exiting
</code></pre></div></div>

<p>it will echo each line you type, one at a time, until you type <em>ctrl-D</em>.</p>

<p>Wait.</p>

<p>One line at a time? Why? That is, why doesn’t it wait until I type all three lines and a <em>ctrl-D</em> before it echos the buffer?</p>

<p>The answer is that the newline character on the input line causes the call to <em>read()</em> to complete and return. It still what you want. Try putting the three different sentences in a .txt file and running <em>./my-cat &lt; my.txt</em>. It should just print the lines out in the order they appear.</p>

<p>Also notice that the messages <em>my-cat</em> prints always go to the terminal because I print them to Standard Error. I use Standard Error in this for reasons that will become clear in a moment. However, notice that <em>my-cat</em> prints its pid every time it reads something or writes something.</p>

<p>To create a chain of <em>my-cat</em> process, each of which reads from the one before it in the chain and write to the one after it in the chain, you need to</p>

<ul>
  <li>create a pipe to serve as the communication channel between processes</li>
  <li>in the up-stream process make make stdout write the write end of the pipe</li>
  <li>in the down stream process make stdin read in the read end of the pipe</li>
  <li>repeatYou also need to make sure that the first process in the chain gets Standard In from the original process (i.e the terminal) and the last process in the chain gets the Standard Out from the original process.</li>
</ul>

<p>To change file descriptors you need to use the system calls <em>dup()</em> or <em>dup2()</em>. I prefer <em>dup2()</em> because it is more explicit. These calls duplicate an open file descriptor. The <em>dup()</em> call will choose the lowest numbered file descriptor that is unopened as the target and <em>dup2()</em> lets you specify which file descriptor you want to use as the target.</p>

<p>For example</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"./my-file.txt"</span><span class="p">,</span><span class="n">O_RDWR</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">dup</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</code></pre></div></div>

<p>will set the Standard In file descriptor to be the same file descriptor as <em>fd</em>. Thus when your process calls <em>read(0,…)</em> it will not be reading from the terminal any longer but from the file. The sequence</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"./my-file.txt"</span><span class="p">,</span><span class="n">O_RDWR</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>does the same. If you leave out the call to <em>close()</em> for the target, it will close it for you.</p>

<p>Thus <em>dup()</em> and <em>dup2()</em> are ways that you can control file descriptors in general. More specifically, you can use them to change the Standard In and Standard Out of a process to be the read and write ends of a pipe.</p>

<p>In <a href="https://www.gaeblog.com/assets/pipe-4.c">pipe-4.c</a> the code does, more or less what the shell does when you use the | symbol create chains of programs separated by pipes.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt; unistd.h &gt;
#include &lt; stdlib.h &gt;
#include &lt; stdio.h &gt;
#include &lt; string.h &gt;
#include &lt; fcntl.h &gt;
#include &lt; sys/wait.h &gt;
</span>
<span class="cm">/*
 * simple program creating a pipe between a set of processes
 * that read and write stdin and stdout
 * first child get stdin of parent
 * last child gets stdout of parent
 */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">child_id</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">child_status</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pipe_desc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">read_buffer</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">file_name</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">proc_count</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">last_stdout</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"usage: pipe-4 executable-file number-of-procs</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*
     * get the arguments
     */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_name</span><span class="p">));</span>
    <span class="n">proc_count</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

    <span class="cm">/*
     * save the parent stdout for the last child
     */</span>
     <span class="o">**</span><span class="n">last_stdout</span> <span class="o">=</span> <span class="n">dup</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="o">**</span> 

    <span class="cm">/*
     * create pipes, fork and exec the processes
     */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">proc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*
         * create the pipe
         */</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"error creating pipe</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/*
         * then fork
         */</span>
        <span class="n">child_id</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">child_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/*
             * child closes standard out
             */</span>
             <span class="o">**</span><span class="n">close</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="cm">/*
             * child dups the write end of the pipe
             * if it is not the last child, otherwise
             * it dups the last_stdout it got from the parent
             * the closed stdout will be chosen as the
             * target
             */</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">proc_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">dup2</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">dup2</span><span class="p">(</span><span class="n">last_stdout</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
                <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span><span class="o">**</span> 
            <span class="cm">/*
             * child runs the program
             */</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">execve</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">envp</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"parent error: %s didn't exec</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">file_name</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
             <span class="o">*</span><span class="err">*/</span><span class="o">*</span>
             <span class="o">*</span> <span class="n">parent</span> <span class="n">closes</span> <span class="n">standard</span> <span class="n">in</span>
             <span class="err">*/</span>
            <span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="cm">/*
             * parent dups the read end of the pipe for the
             * next child
             */</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">proc_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">dup2</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            <span class="n">close</span><span class="p">(</span><span class="n">pipe_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="o">**</span> 
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">close</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">last_stdout</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="cm">/*
     * parent now waits for the children to exit
     */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">proc_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">child_id</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child_status</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>This code is worth understanding. It takes the name of a file as its first argument and the number of processes to create as its second argument. The processes must read and write Standard In and Standard Out (like <a href="https://www.gaeblog.com/assets/my-cat.c">my-cat.c</a>.</p>

<p>Try running it:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./pipe-4 ./my-cat 2
pid: 34122 <span class="nt">--</span> I am my-cat and I have started
pid: 34123 <span class="nt">--</span> I am my-cat and I have started
I love OS
pid: 34122 <span class="nb">read </span>some data
pid: 34122 wrote some data
pid: 34123 <span class="nb">read </span>some data
I love OS
pid: 34123 wrote some data
pid: 34122 <span class="nt">--</span> I am my-cat and I am exiting
pid: 34123 <span class="nt">--</span> I am my-cat and I am exiting
</code></pre></div></div>

<p>The code forked two children (pid: 34122 and pid: 34123). When you type an important sentence to the terminal, 34122 wakes up, reads the message from Standard In (file descriptor 0) and writes it to Stabdard Out (file descriptor 1). The parent has been careful to leave file descriptor alone on its first fork so that the first child gets the terminal as Standard IN. Then 34123 wakes up, reads its Standard In, and writes it to its Standard Out. In this case, however, since it is the end of the chain, the parent has arranged that its Standard Out is the terminal. Thus you see the sentence a second time when 34123 writes it. Try it with three processes</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./pipe-4 ./my-cat 3
pid: 34201 <span class="nt">--</span> I am my-cat and I have started
pid: 34202 <span class="nt">--</span> I am my-cat and I have started
pid: 34203 <span class="nt">--</span> I am my-cat and I have started
I love OS
pid: 34201 <span class="nb">read </span>some data
pid: 34201 wrote some data
pid: 34202 <span class="nb">read </span>some data
pid: 34202 wrote some data
pid: 34203 <span class="nb">read </span>some data
I love OS
pid: 34203 wrote some data
pid: 34201 <span class="nt">--</span> I am my-cat and I am exiting
pid: 34202 <span class="nt">--</span> I am my-cat and I am exiting
pid: 34203 <span class="nt">--</span> I am my-cat and I am exiting
</code></pre></div></div>

<p>and with four</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./pipe-4 ./my-cat 4
pid: 34225 <span class="nt">--</span> I am my-cat and I have started
pid: 34226 <span class="nt">--</span> I am my-cat and I have started
pid: 34228 <span class="nt">--</span> I am my-cat and I have started
pid: 34227 <span class="nt">--</span> I am my-cat and I have started
I love OS
pid: 34225 <span class="nb">read </span>some data
pid: 34225 wrote some data
pid: 34226 <span class="nb">read </span>some data
pid: 34226 wrote some data
pid: 34227 <span class="nb">read </span>some data
pid: 34227 wrote some data
pid: 34228 <span class="nb">read </span>some data
I love OS
pid: 34228 wrote some data
pid: 34225 <span class="nt">--</span> I am my-cat and I am exiting
pid: 34226 <span class="nt">--</span> I am my-cat and I am exiting
pid: 34227 <span class="nt">--</span> I am my-cat and I am exiting
pid: 34228 <span class="nt">--</span> I am my-cat and I am exiting
</code></pre></div></div>

<p>Each time, the first process in the set of children that has been forked reads the string from Standard In and passes it to the next process in the chain. The parent gave the first child its own Standard In which was the terminal so that first child reads the terminal. Eventually, the last process in the chain writes it to Standard Out which has been set to be the same Standard Out the parent had when it ran.</p>

<p>The logic takes a little while to understand. In a loop, the parent creates a pipe and forks a child. The child, before it execs the program specified as the second argument, dups the write end of the pipe to Standard Out so that after the exec, the program that is running will be writing the write end of the pipe when it writes to its Standard Out.</p>

<p>The parent, then, must dup the read end of the pipe into its own Standard In so that when it forks the next time, the child will receive the read end of the pipe the parent created on the last iteration. Thus the child before it in the loop will be writing the write end and the next child will be reading the read end.</p>

<p>The logic must also detect when the last child in the list has been forked and, instead of duping the write end of the pipe, it must dup the original Standard Out for the parent (which is duped at the start of the parent as <em>last_stdout</em>).</p>

<p>Lastly, because <em>my-cat</em> is also trying to print a status message, if it uses <em>printf()</em> Linux will try to use Standard Out. It actually works, but has a problem as the processes exit because Standard Out isn’t being closed on process exit. To keep things “straight” I’ve used Standard Error (which none of the code change with <em>dup()</em> so that <em>my-cat</em> can send messages to the screen without using Standard Out.</p>

<p>That’s it for the basic system calls in Linux. There are many others, but these are the ones you need to do file I/O, create and descroy processes and allow processes to communicate between themselves.)}</p>

        </article>
        <hr>

        
        
            
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
            
            
                
                    
                
            
                
                    
                
            
        
        

        <div class="post-recent">
    <div class="pre">
        
        <p><strong>上一篇</strong> <a href="/2017/06/08/Kthreads/">Kthreads</a></p>
        
    </div>
    <div class="nex">

        
        <p><strong>下一篇</strong> <a href="/2017/06/08/Memory-Management/">Memory Management</a></p>
        
    </div>
</div>


        <h2 id="comments">Comments</h2>
        


<div id="disqus_thread"></div>
<script>
    /**
     * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */

    var disqus_config = function() {
        this.page.url = 'https://www.gaeblog.com/2017/06/08/System-Calls/'; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://www.gaeblog.com/2017/06/08/System-Calls/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };

    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document,
            s = d.createElement('script');

        s.src = '//https-seraphroy-github-io-1.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>




    </div>
    <button class="anchor"><i class="fa fa-anchor"></i></button>
    <div class="right">
        <div class="wrap">

             <div class="side content" id="search-div">
                 <div>
    <i class="fa fa-search"></i>
    Search
</div>
<div id="site_search">
    <input type="text" id="search_box" placeholder="Search..." >
</div>
<div id="search_results"></div>

<link rel="stylesheet" type="text/css" href="https://www.gaeblog.com/assets/stylesheets/main.css">
<script type="text/javascript" src="https://www.gaeblog.com/assets/js/search.js"></script>
<script type="text/javascript" src="https://www.gaeblog.com/assets/js/node_modules/simpleblogsearch/index.js"></script>

<script>
SimpleBlogSearch({
   searchDataPath: '/assets/search_data.json',
   dataType: 'json',
   processDataFunc: function(data){ return data },
   searchInputID: 'search_box',
   resultsDivID: 'search_results',
   resultULClass: 'content-ul search-ul content-side',
   highlightKeywordClass: 'search_keyword',
   limit: 4,

});
</script>

             </div>
            <!-- Content -->
            <div class="side content">
                <div>
                    Content
                </div>
                <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#system-calls">System Calls</a>
<ul>
<li class="toc-entry toc-h3"><a href="#getting-the-process-identifier">Getting the process identifier</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#files">Files</a>
<ul>
<li class="toc-entry toc-h3"><a href="#reading-the-data-back">Reading the data back</a></li>
<li class="toc-entry toc-h3"><a href="#seeking-to-an-offset">Seeking to an offset</a></li>
<li class="toc-entry toc-h3"><a href="#standard-in-standard-out-and-standard-error">Standard In, Standard Out and Standard Error</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#forkexecwait">Fork/Exec/Wait</a>
<ul>
<li class="toc-entry toc-h3"><a href="#fork">Fork</a></li>
<li class="toc-entry toc-h3"><a href="#exec">Exec</a></li>
<li class="toc-entry toc-h3"><a href="#night-of-the-living-dead">Night of the Living Dead</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#pipes">Pipes</a>
<ul>
<li class="toc-entry toc-h3"><a href="#putting-it-all-together">Putting It All Together</a></li>
</ul>
</li>
</ul>
                <ul id="content-side" class="content-ul">
                    
                    <li><a href="#comments">Comments</a></li>
                </ul>
            </div>
            <!-- 其他div框放到这里 -->
            <!-- <div class="side">bbbb</div> -->
        </div>
    </div>
</div>
<script>
/**
 * target _blank
 */
(function() {
    var aTags = document.querySelectorAll('article a:not([id])')
    for (var i = 0; i < aTags.length; i++) {
        aTags[i].setAttribute('target', '_blank')
    }
}());
</script>
<script src="/assets/js/pageContent.js " charset="utf-8"></script>


    <footer class="site-footer">


    <div class="wrapper">

        <p class="description">
            
        </p>
        <p class="contact">
            Contact me at: 
            <a href="https://github.com/SeraphRoy" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a>  
            <a href="mailto:royxagain@gmail.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a>     
            <a href="https://www.facebook.com/SeraphRoy" title="Facebook"><i class="fa fa-facebook-official" aria-hidden="true"></i></a>   
            <a href="https://www.linkedin.com/in/yanxichen" title="LinkedIn"><i class="fa fa-linkedin" aria-hidden="true"></i></a>  
        </p>
        <p>
            本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </p>
        <p class="power">
            <span>
                Site powered by <a href="https://jekyllrb.com/">Jekyll</a> & <a href="https://pages.github.com/">Github Pages</a>.
            </span>
            <span>
                Theme designed by <a href="https://github.com/Gaohaoyang">HyG</a>.
            </span>
        </p>
    </div>
</footer>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <div class="back-to-top">
    <a href="#top" data-scroll>
        <i class="fa fa-arrow-up" aria-hidden="true"></i>
    </a>
</div>

    <script src=" /assets/js/main.js " charset="utf-8"></script>
    <script src=" /assets/js/smooth-scroll.min.js " charset="utf-8"></script>
    <script type="text/javascript">
      smoothScroll.init({
        speed: 500, // Integer. How fast to complete the scroll in milliseconds
        easing: 'easeInOutCubic', // Easing pattern to use
        offset: 20, // Integer. How far to offset the scrolling anchor location in pixels
      });
    </script>
    <!-- <script src=" /assets/js/scroll.min.js " charset="utf-8"></script> -->
  </body>

</html>
