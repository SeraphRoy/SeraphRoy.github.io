{
  "html": "<p>Here is a hopefully familiar example of how to use this library using the <a href=\"http://www.cs.ucsb.edu/~rich/class/cs170/notes/CondVar/index.html\">Client-trader Simulation</a> from previous classes. Here is a version of <a href=\"https://seraphroy.github.io/assets/market-kthreads.c\">market-kthreads.c</a> that uses the kthreads library. There are a couple things worth noting here. First, notice that it doesn’t bother protecting against any of the race conditions (the mutexes are gone) that the pthreads version does. That is, there is a distinct lack of calls to any primitive implementing mutual exclusion. This is because we know kthreads is strictly non-preemptive, and so there are no race conditions between running threads. Don’t be confused, however. In the OS you build, you can create race conditions – it just won’t be between runnable threads. We’ll discuss this at length later. for now it is enough for you to know that race conditions are possible in your labs, but not in this example. However, with that difference and small differences in the return values when threads are created and destroyed, the code is the same as the <a href=\"https://seraphroy.github.io/assets/market-semaphore.c\">semaphore version of the client-trader simulation</a>. As we saw before, this is a pretty elegant solution to the problem. Run it a few times, however, and you’ll see that there is no speed-up gained through the use of multiple threads. Why? Kthreads doesn’t use multiple processors – it is strictly for decomposing a problem into thread like tasks and as this example shows converting something from kthreads to pthreads and back again is pretty simple.</p>",
  "content": "Here is a hopefully familiar example of how to use this library using the Client-trader Simulation from previous classes. Here is a version of market-kthreads.c that uses the kthreads library. There are a couple things worth noting here. First, notice that it doesn’t bother protecting against any of the race conditions (the mutexes are gone) that the pthreads version does. That is, there is a distinct lack of calls to any primitive implementing mutual exclusion. This is because we know kthreads is strictly non-preemptive, and so there are no race conditions between running threads. Don’t be confused, however. In the OS you build, you can create race conditions – it just won’t be between runnable threads. We’ll discuss this at length later. for now it is enough for you to know that race conditions are possible in your labs, but not in this example. However, with that difference and small differences in the return values when threads are created and destroyed, the code is the same as the semaphore version of the client-trader simulation. As we saw before, this is a pretty elegant solution to the problem. Run it a few times, however, and you’ll see that there is no speed-up gained through the use of multiple threads. Why? Kthreads doesn’t use multiple processors – it is strictly for decomposing a problem into thread like tasks and as this example shows converting something from kthreads to pthreads and back again is pretty simple.",
  "tag_name": "p",
  "hierarchy": {
    "lvl0": "The Kthreads Library",
    "lvl1": "Example",
    "lvl2": null,
    "lvl3": null,
    "lvl4": null,
    "lvl5": null,
    "lvl6": null
  },
  "anchor": "example",
  "weight": {
    "position": 11,
    "heading": 80
  },
  "draft": false,
  "categories": [
    "Operating System"
  ],
  "layout": "post",
  "title": "Kthreads",
  "tags": [
    "Thread"
  ],
  "author": "Yanxi Chen",
  "mathjax": true,
  "ext": ".md",
  "date": 1496959560,
  "excerpt_html": "<ul id=\"markdown-toc\">   <li><a href=\"#the-kthreads-library\" id=\"markdown-toc-the-kthreads-library\">The Kthreads Library</a>    <ul>       <li><a href=\"#the-interface\" id=\"markdown-toc-the-interface\">The Interface</a></li>     </ul>   </li> </ul>  <h1 id=\"the-kthreads-library\">The Kthreads Library</h1>  <p>Kthreads is a relatively simple, non-preemptive threads library that we will be using to implement our operating system later in the labs. For our purposes, it has an advantage over pthreads because it works in the debugger and because it will not interfere with the simulator (making your development life easier). It’s also simple enough to understand, and therefore makes for a good teaching tool.</p>  <p>The kthreads library is at <strong>/cs/faculty/rich/cs170/lib/libkt.a</strong>, the source is at <strong>/cs/faculty/rich/cs170/src/libkt/</strong>, and the header is <strong>/cs/faculty/rich/cs170/include</strong>. You will also need to link to <strong>/cs/faculty/rich/cs170/lib/libfdr.a</strong> which provides some basic C functions like linked lists and red-black trees.</p>  <hr />  <h2 id=\"the-interface\">The Interface</h2>  <p>Using kthreads is pretty straightforward, so we will not go into it in much detail. You should all understand the basic thread primitives by now although you need to remember that (unlike in the case of pthreads) kthreads do not pre-empt each other. The kthreads calls are:</p>  <ul>   <li><code class=\"highlighter-rouge\">void *kt_fork(void *(*func)(void *), void *arg);</code></li>   <li><code class=\"highlighter-rouge\">void kt_exit();</code></li>   <li><code class=\"highlighter-rouge\">void kt_join(void *kt_id);</code></li>   <li><code class=\"highlighter-rouge\">void kt_joinall();</code></li>   <li><code class=\"highlighter-rouge\">void *kt_self();</code></li>   <li><code class=\"highlighter-rouge\">void kt_yield();</code></li>   <li><code class=\"highlighter-rouge\">void kt_sleep(int sec);</code></li> </ul>  <p>Kthreads includes <a href=\"http://www.cs.ucsb.edu/~rich/class/cs170/notes/Semaphores/index.html\">counting semaphores</a> as its only synchronization primitive.</p>  <ul>   <li><code class=\"highlighter-rouge\">kt_sem make_kt_sem(int initval);</code></li>   <li><code class=\"highlighter-rouge\">void kill_kt_sem(kt_sem ksem);</code></li>   <li><code class=\"highlighter-rouge\">void P_kt_sem(kt_sem ksem);</code></li>   <li><code class=\"highlighter-rouge\">void V_kt_sem(kt_sem ksem);</code></li>   <li><code class=\"highlighter-rouge\">int kt_getval(kt_sem s);</code></li> </ul>  <p>The basic kt primitives (fork, exit, join) play the same role that pthread_create, pthread_exit, and pthread_join play for pthreads. Of the other functions, <code class=\"highlighter-rouge\">kt_yield()</code> interrupts the current thread and lets the scheduler run a new one. This primitive is nice in non-pre-emptive thread systems because it allows a kind of “polling” of the scheduler. A thread calling <code class=\"highlighter-rouge\">kt_yield()</code> blocks itself and allows other threads that can run to go ahead. When no more runnable threads are available, the yielding thread will be resumed at the point of the yield.</p>  <p>The call <code class=\"highlighter-rouge\">kt_sleep()</code> sleeps the current thread for a specified time period. Again, because the thread is non-pre-emptive, the thread will be “awakened” and made runnable after the specified time, but it will not actually run until it is given the CPU.</p>  <p>The call <code class=\"highlighter-rouge\">kt_self()</code> returns the thread id. No confusion here.</p>  <p>The function <code class=\"highlighter-rouge\">kt_joinall()</code> is a useful function that causes the current thread to block until all other threads have either exited or blocked on a semaphore.</p>  <p>You will find that this function is particularly handy in designing your OS.</p>  <p>The semaphore primitives are exactly as we discussed. <code class=\"highlighter-rouge\">make_kt_sem()</code> creates a semaphore with a value greater than or equal to zero, and <code class=\"highlighter-rouge\">kill_kt_sem()</code> destroys (and frees) it. <code class=\"highlighter-rouge\">P_kt_sem()</code> decrements the semaphore’s value by 1, and if it is negative blocks it. <code class=\"highlighter-rouge\">V_kt_sem()</code> increments the value by one, and it if it is zero or less it unblocks one thread.</p>  <p>There is also a call to interrogate the current value of the semaphore – <code class=\"highlighter-rouge\">kt_getval()</code>. While not strictly part of the semaphore API, there are occasions where the ability to know how many threads are blocked on a semaphore is quite handy.</p>  <hr />",
  "excerpt_text": "The Kthreads Library The Interface The Kthreads Library Kthreads is a relatively simple, non-preemptive threads library that we will be using to implement our operating system later in the labs. For our purposes, it has an advantage over pthreads because it works in the debugger and because it will not interfere with the simulator (making your development life easier). It’s also simple enough to understand, and therefore makes for a good teaching tool. The kthreads library is at /cs/faculty/rich/cs170/lib/libkt.a, the source is at /cs/faculty/rich/cs170/src/libkt/, and the header is /cs/faculty/rich/cs170/include. You will also need to link to /cs/faculty/rich/cs170/lib/libfdr.a which provides some basic C functions like linked lists and red-black trees. The Interface Using kthreads is pretty straightforward, so we will not go into it in much detail. You should all understand the basic thread primitives by now although you need to remember that (unlike in the case of pthreads) kthreads do not pre-empt each other. The kthreads calls are: void *kt_fork(void *(*func)(void *), void *arg); void kt_exit(); void kt_join(void *kt_id); void kt_joinall(); void *kt_self(); void kt_yield(); void kt_sleep(int sec); Kthreads includes counting semaphores as its only synchronization primitive. kt_sem make_kt_sem(int initval); void kill_kt_sem(kt_sem ksem); void P_kt_sem(kt_sem ksem); void V_kt_sem(kt_sem ksem); int kt_getval(kt_sem s); The basic kt primitives (fork, exit, join) play the same role that pthread_create, pthread_exit, and pthread_join play for pthreads. Of the other functions, kt_yield() interrupts the current thread and lets the scheduler run a new one. This primitive is nice in non-pre-emptive thread systems because it allows a kind of “polling” of the scheduler. A thread calling kt_yield() blocks itself and allows other threads that can run to go ahead. When no more runnable threads are available, the yielding thread will be resumed at the point of the yield. The call kt_sleep() sleeps the current thread for a specified time period. Again, because the thread is non-pre-emptive, the thread will be “awakened” and made runnable after the specified time, but it will not actually run until it is given the CPU. The call kt_self() returns the thread id. No confusion here. The function kt_joinall() is a useful function that causes the current thread to block until all other threads have either exited or blocked on a semaphore. You will find that this function is particularly handy in designing your OS. The semaphore primitives are exactly as we discussed. make_kt_sem() creates a semaphore with a value greater than or equal to zero, and kill_kt_sem() destroys (and frees) it. P_kt_sem() decrements the semaphore’s value by 1, and if it is negative blocks it. V_kt_sem() increments the value by one, and it if it is zero or less it unblocks one thread. There is also a call to interrogate the current value of the semaphore – kt_getval(). While not strictly part of the semaphore API, there are occasions where the ability to know how many threads are blocked on a semaphore is quite handy.",
  "slug": "Kthreads",
  "type": "post",
  "url": "/2017/06/08/Kthreads/",
  "objectID": "3415e47d4195d7ee7ce4d802e2b9ca16"
}